{
    "docs": [
        {
            "location": "/", 
            "text": "Meet Will\n\n\nWill is the friendliest, easiest-to-teach bot you've ever used.  He works on Slack, HipChat, Rocket.Chat, and more.\n\n\nHe makes teaching your chat bot this simple:\n\n\n@respond_to(\nhi\n)\ndef say_hello(self, message):\n    self.say(\noh, hello!\n)\n\n\n\n\nLots of batteries are included, and you can get your own will up and running in a couple of minutes.  \n\n\nWill started by \nSteven Skoczen\n, and has been \ncontributed to by lots of folks\n.\n\n\nCheck out the quickstart below!\n\n\n\n\n\nQuickstart\n\n\nUpgrading from Will 1.x or 0.x? \nCheck out the Upgrade Guide\n.\n\n\nHere's how to set up your system and get will running.  If you already write python, it'll probably take less than 5 minutes.\n\n\n\n\nInstall prerequisites\n\n\nWill doesn't need much, just python, a place to store things, and a way to communicate.\n\n\nWill can store stuff in Redis, Couchbase, or local storage.  Our recommended backend is redis, and we'll describe getting it set up below. \nInformation on using Couchbase or local storage is here\n.\n\n\nWill's communication layer works via publish-subscribe, and at the moment, only supports Redis.  If that's a blocker for you, ZeroMQ, and a pure python built-in layer are coming in 2.1.\n\n\nInstall redis \n 2.4\n\n\nOfficial documentation is at \nredis.io\n.\n\n\nIf you're on Mac OS X, and using \nhomebrew\n, you can simply:\n\n\nbrew install redis\n\n\n\n\nOn a Redhat (RHEL, Centos, Fedora) machine you can:\n\n\nsudo yum install redis\nsudo service redis enable\nsudo service redis start\n\n\n\n\nOn a Debian (Ubuntu, Mint, KNOPPIX) machine to properly install follow the \nRedis Quickstart\n. But you can start more quickly with:\n\n\nsudo apt-get install redis-server\nredis-server\n\n\n\n\nInstall python \n 2.6\n\n\nMost modern operating systems (Mac OS X, Linux, BSDs, etc) ship with python installed, but if you don't have it, all the info is at \npython.org\n.\n\n\nInstall virtualenv\n\n\nVirtualenv is a tool that lets you keep different python projects separate. It is highly recommended for will (and all other python development!)\n\n\nThe python guide has \na great tutorial on virtualenv\n, if you don't already have it running.  I'd recommend installing the excellent \nvirtualenvwrapper\n library it mentions as well.\n\n\nSet up a virtualenv for will\n\n\nIf you are using virtualenv wrapper:\n\n\n$ mkproject my_will\n# ... some output, setting up the virtualenv\n$ workon my_will\n(my_will) $ \n\n\n\n\nYou're now all ready to install will!\n\n\nGet will running locally\n\n\nSetting up the project\n\n\nInstalling will is simple easy.  Ready? Go!\n\n\nFrom your virtualenv and the folder you want to set up your will in,\n\n\n(my_will) $ pip install will\n# ... output from a bunch of pip libraries installing\n\n(my_will) $ generate_will_project\n# ... output from will making your new project\n\n(my_will) $ pip install -r requirements.txt\n# ... install any needed libraries for your chosen backends.\n\n(my_will) $ ./run_will.py\n# .. the magic begins\n\n\n\n\nThat's it!\n\n\nNote that the first time you run, you'll probably be missing some configuration. That's OK - \nrun_will\n will check your environment, and walk you through getting and setting any necessary config.  We'll go through the nitty-gritty later, but if you have any odd setup problems, look in \nconfig.py\n - that's where all of the non-sensitive data is stored.\n\n\n\nThis is totally normal output.\n\n\nEventually, you'll reach this screen of joy.  Now, it's time to play!\n\n\n\n\nTesting will out\n\n\nOnce your will is up and running, hop into any of your chat rooms (or just the terminal), and say hello!\n\n\n@will hi\n\n\n\n\n@will help\n\n\n\n\nYou're up and running - now it's time to \nteach your will a few things\n!", 
            "title": "Get Started"
        }, 
        {
            "location": "/#meet-will", 
            "text": "Will is the friendliest, easiest-to-teach bot you've ever used.  He works on Slack, HipChat, Rocket.Chat, and more.  He makes teaching your chat bot this simple:  @respond_to( hi )\ndef say_hello(self, message):\n    self.say( oh, hello! )  Lots of batteries are included, and you can get your own will up and running in a couple of minutes.    Will started by  Steven Skoczen , and has been  contributed to by lots of folks .  Check out the quickstart below!", 
            "title": "Meet Will"
        }, 
        {
            "location": "/#quickstart", 
            "text": "Upgrading from Will 1.x or 0.x?  Check out the Upgrade Guide .  Here's how to set up your system and get will running.  If you already write python, it'll probably take less than 5 minutes.", 
            "title": "Quickstart"
        }, 
        {
            "location": "/#install-prerequisites", 
            "text": "Will doesn't need much, just python, a place to store things, and a way to communicate.  Will can store stuff in Redis, Couchbase, or local storage.  Our recommended backend is redis, and we'll describe getting it set up below.  Information on using Couchbase or local storage is here .  Will's communication layer works via publish-subscribe, and at the moment, only supports Redis.  If that's a blocker for you, ZeroMQ, and a pure python built-in layer are coming in 2.1.", 
            "title": "Install prerequisites"
        }, 
        {
            "location": "/#install-redis-24", 
            "text": "Official documentation is at  redis.io .  If you're on Mac OS X, and using  homebrew , you can simply:  brew install redis  On a Redhat (RHEL, Centos, Fedora) machine you can:  sudo yum install redis\nsudo service redis enable\nsudo service redis start  On a Debian (Ubuntu, Mint, KNOPPIX) machine to properly install follow the  Redis Quickstart . But you can start more quickly with:  sudo apt-get install redis-server\nredis-server", 
            "title": "Install redis &gt; 2.4"
        }, 
        {
            "location": "/#install-python-26", 
            "text": "Most modern operating systems (Mac OS X, Linux, BSDs, etc) ship with python installed, but if you don't have it, all the info is at  python.org .", 
            "title": "Install python &gt; 2.6"
        }, 
        {
            "location": "/#install-virtualenv", 
            "text": "Virtualenv is a tool that lets you keep different python projects separate. It is highly recommended for will (and all other python development!)  The python guide has  a great tutorial on virtualenv , if you don't already have it running.  I'd recommend installing the excellent  virtualenvwrapper  library it mentions as well.", 
            "title": "Install virtualenv"
        }, 
        {
            "location": "/#set-up-a-virtualenv-for-will", 
            "text": "If you are using virtualenv wrapper:  $ mkproject my_will\n# ... some output, setting up the virtualenv\n$ workon my_will\n(my_will) $   You're now all ready to install will!", 
            "title": "Set up a virtualenv for will"
        }, 
        {
            "location": "/#get-will-running-locally", 
            "text": "", 
            "title": "Get will running locally"
        }, 
        {
            "location": "/#setting-up-the-project", 
            "text": "Installing will is simple easy.  Ready? Go!  From your virtualenv and the folder you want to set up your will in,  (my_will) $ pip install will\n# ... output from a bunch of pip libraries installing\n\n(my_will) $ generate_will_project\n# ... output from will making your new project\n\n(my_will) $ pip install -r requirements.txt\n# ... install any needed libraries for your chosen backends.\n\n(my_will) $ ./run_will.py\n# .. the magic begins  That's it!  Note that the first time you run, you'll probably be missing some configuration. That's OK -  run_will  will check your environment, and walk you through getting and setting any necessary config.  We'll go through the nitty-gritty later, but if you have any odd setup problems, look in  config.py  - that's where all of the non-sensitive data is stored.  \nThis is totally normal output.  Eventually, you'll reach this screen of joy.  Now, it's time to play!", 
            "title": "Setting up the project"
        }, 
        {
            "location": "/#testing-will-out", 
            "text": "Once your will is up and running, hop into any of your chat rooms (or just the terminal), and say hello!  @will hi   @will help   You're up and running - now it's time to  teach your will a few things !", 
            "title": "Testing will out"
        }, 
        {
            "location": "/upgrading_to_2/", 
            "text": "Upgrading to Will 2.0\n\n\n\nWill was born four years ago, and 0.x and 1.x lived long, good lives.\n\n\nBut as the years passed, there were increasing concerns about HipChat lock-in, and it was time to make Will smarter.  \n\n\nSo six months ago, work on Will 2.0 began, and today it's finally here! All of our Wills are free from lock-in, future-proofed, and whole lot smarter.  If you're just hearing about this, it's worth a quick read of the \nrelease announcement\n for a bit more context!\n\n\nThe Short Version: Just pip install\n\n\nWhile Will has picked up a bunch of features and improvements in 2.0, we've aimed to keep him backwards-compatable with 1.x and 0.x releases.  If you weren't using any undocumented internal methods and you're already using redis, upgrading should be as easy as:\n\n\npip install --upgrade will\n\n\n\n\nFrom there, you can just \n./run_will.py\n, and things should Just Work.\n\n\nYou will, however, see a lot of output from Will, telling you that some names have changed, and asking you to update them in your \nconfig.py\n when you have time.  You can either just follow those instructions, or the guide below.\n\n\nThe Long Version:\n\n\n1. Add IO backends.\n\n\nIf you're planning to continue only using HipChat (until it's replaced by Stride), we'd recommend that you add this to your \nconfig.py\n:\n\n\nIO_BACKENDS = [\n    \nwill.backends.io_adapters.hipchat\n,\n    \nwill.backends.io_adapters.shell\n,\n    # \nwill.backends.io_adapters.slack\n,\n    # \nwill.backends.io_adapters.rocketchat\n,\n]\n\n\n\n\nThat will enable the HipChat and local shell stdin/stdout backend, for easy testing. \n\n\nIf you want to also bring your Will into a Slack or Rocket.Chat room in the future, just uncomment that backend and restart!\n\n\n2. Update the HipChat tokens to be namespaced.\n\n\nYou'll see this starting up, but when you have time, update your tokens as follows:\n\n(If you're using \nWILL_\n environment variables, please add the \nWILL_\n as needed:)\n\n\n\n\nUSERNAME\n becomes \nHIPCHAT_USERNAME\n\n\nTOKEN\n or \nV1_TOKEN\n become \nHIPCHAT_V1_TOKEN\n\n\nV2_TOKEN\n becomes \nHIPCHAT_V2_TOKEN\n\n\nDEFAULT_ROOM\n becomes \nHIPCHAT_DEFAULT_ROOM\n\n\nHANDLE\n should be removed, as it's now pulled live from the HipChat servers and not used.\n\n\nNAME\n should be removed, as it's now pulled live from the HipChat servers and not used.\n\n\nPASSWORD\n becomes \nHIPCHAT_PASSWORD\n\n\nROOMS\n becomes \nHIPCHAT_ROOMS\n\n\n\n\n3. Set up Redis\n\n\nAt the moment, Redis is the only working pubsub backend, and is required to run Will. So, if you're not already running it, you'll need it for 2.x.\n\n\nIf this is impossible for your setup, ZeroMQ support is in the works, and we're looking to add a pure-python backend as well in 2.1 or 2.2.  Creating a new pubsub backend just requires subclassing \nBasePubSub\n and implementing four methods - so if someone has a little time to bring those along, a pull request is welcome!\n\n\n4. Set your encryption secret key.\n\n\nWill now encrypts all messages on the pubsub wire and in storage by default.  Without a \nSECRET_KEY\n set, he'll auto-generate one based on the machine MAC address, but this isn't a perfect solution, and will mean that he can't access his storage if there are hardware changes (or he's running in a virtualized environment that has shifting MACs.)\n\n\nPlease set \nSECRET_KEY\n as soon as possible.\n\n\nThe recommended way is to set it as an environmental variable, \nWILL_SECRET_KEY\n, in an environment that is secured and you trust.  Any string will work, and entropy is good. \n\n\n5. Set the new 2.0 settings to your liking.\n\n\nWill 2 ships with bunch of new features, and though we've provided sensible defaults, if you'd like, you can update your \nconfig.py\n with your preferences.\n\n\nThe simplest way to see everything is to have Will generate a \nconfig.py.dist\n that you can use for comparison:\n\n\n$ generate_will_project --config-dist-only\n...\nCreated a config.py.dist.  Open it up to see what's new!\n\n\n\n\nIt's worth reading through the new \nconfig.py\n, but here's a few areas specifically worth a look:\n\n\nPlatform and Decision-making\n\n\nAs mentioned above, there are now multiple IO backends and platforms that Will can communicate on. It's also now easy to \nwrite your own\n, pull requests are very welcome, and more are coming soon.  Here's all the options:\n\n\nIO_BACKENDS = [\n    \nwill.backends.io_adapters.slack\n,\n    \nwill.backends.io_adapters.hipchat\n,\n    \nwill.backends.io_adapters.rocketchat\n,\n    \nwill.backends.io_adapters.shell\n,\n]\n\n\n\n\nWill 2 also comes with pluggable brains - split into Analysis, Generation, and Execution backends.  The defaults are solid and behave similarly to Will 1.0 (the only difference is a high-confidence fuzzy matching engine), but if you're interested in making your Will more flexible, or adding more context to his responses, building \ncustom backends is easy\n.\n\n\nHere's all of the options, with the defaults uncommented.   It's worth pulling this into your \nconfig.py\n.\n\n\n# Backends to analyze messages and generate useful metadata\nANALYZE_BACKENDS = [\n    \nwill.backends.analysis.nothing\n,\n    \nwill.backends.analysis.history\n,\n]\n\n# Backends to generate possible actions, and metadata about them.\nGENERATION_BACKENDS = [\n    \nwill.backends.generation.strict_regex\n,\n    \nwill.backends.generation.fuzzy_all_matches\n,\n    # \nwill.backends.generation.fuzzy_best_match\n,\n]\n\n# The \ndecision making\n backends that look among the generated choices,\n# and decide which to follow. Backends are executed in order, and any\n# backend can stop further evaluation.\nEXECUTION_BACKENDS = [\n    \nwill.backends.execution.best_score\n,\n    # \nwill.backends.execution.all\n,\n]\n\n\n\n\nThere are also a few settings to tweak things like the fuzzy logic.  These have sensible defaults, but you can tweak them to your liking.\n\n\n# Confidence fuzzy generation backends require before Will responds\n# https://pypi.python.org/pypi/fuzzywuzzy\nFUZZY_MINIMUM_MATCH_CONFIDENCE = 90  # Defaults to 90%\nFUZZY_REGEX_ALLOWABLE_ERRORS = 3\n\n\n\n\n6. That's it - let us know how it goes!\n\n\nThat's all you really need to know to flip the switch to Will 2.0.  \n\n\nAs there's a lot of new stuff in this release, it's possible that some bugs have slipped through the cracks.  Please submit anything you find, no matter how small, \ninto the github issue tracker\n.  We'll be active in fixing things ASAP and helping if you're stuck.\n\n\nThanks for using Will, and for going through the big upgrade!  We're excited about what the future holds, and happy to get your bots free from platform lock-in.\n\n\nIf you'd like to do a deeper dive into what's new, check out the documentation \non Will's new brain\n.", 
            "title": "Upgrade to 2.0"
        }, 
        {
            "location": "/upgrading_to_2/#the-short-version-just-pip-install", 
            "text": "While Will has picked up a bunch of features and improvements in 2.0, we've aimed to keep him backwards-compatable with 1.x and 0.x releases.  If you weren't using any undocumented internal methods and you're already using redis, upgrading should be as easy as:  pip install --upgrade will  From there, you can just  ./run_will.py , and things should Just Work.  You will, however, see a lot of output from Will, telling you that some names have changed, and asking you to update them in your  config.py  when you have time.  You can either just follow those instructions, or the guide below.", 
            "title": "The Short Version: Just pip install"
        }, 
        {
            "location": "/upgrading_to_2/#the-long-version", 
            "text": "", 
            "title": "The Long Version:"
        }, 
        {
            "location": "/upgrading_to_2/#1-add-io-backends", 
            "text": "If you're planning to continue only using HipChat (until it's replaced by Stride), we'd recommend that you add this to your  config.py :  IO_BACKENDS = [\n     will.backends.io_adapters.hipchat ,\n     will.backends.io_adapters.shell ,\n    #  will.backends.io_adapters.slack ,\n    #  will.backends.io_adapters.rocketchat ,\n]  That will enable the HipChat and local shell stdin/stdout backend, for easy testing.   If you want to also bring your Will into a Slack or Rocket.Chat room in the future, just uncomment that backend and restart!", 
            "title": "1. Add IO backends."
        }, 
        {
            "location": "/upgrading_to_2/#2-update-the-hipchat-tokens-to-be-namespaced", 
            "text": "You'll see this starting up, but when you have time, update your tokens as follows: \n(If you're using  WILL_  environment variables, please add the  WILL_  as needed:)   USERNAME  becomes  HIPCHAT_USERNAME  TOKEN  or  V1_TOKEN  become  HIPCHAT_V1_TOKEN  V2_TOKEN  becomes  HIPCHAT_V2_TOKEN  DEFAULT_ROOM  becomes  HIPCHAT_DEFAULT_ROOM  HANDLE  should be removed, as it's now pulled live from the HipChat servers and not used.  NAME  should be removed, as it's now pulled live from the HipChat servers and not used.  PASSWORD  becomes  HIPCHAT_PASSWORD  ROOMS  becomes  HIPCHAT_ROOMS", 
            "title": "2. Update the HipChat tokens to be namespaced."
        }, 
        {
            "location": "/upgrading_to_2/#3-set-up-redis", 
            "text": "At the moment, Redis is the only working pubsub backend, and is required to run Will. So, if you're not already running it, you'll need it for 2.x.  If this is impossible for your setup, ZeroMQ support is in the works, and we're looking to add a pure-python backend as well in 2.1 or 2.2.  Creating a new pubsub backend just requires subclassing  BasePubSub  and implementing four methods - so if someone has a little time to bring those along, a pull request is welcome!", 
            "title": "3. Set up Redis"
        }, 
        {
            "location": "/upgrading_to_2/#4-set-your-encryption-secret-key", 
            "text": "Will now encrypts all messages on the pubsub wire and in storage by default.  Without a  SECRET_KEY  set, he'll auto-generate one based on the machine MAC address, but this isn't a perfect solution, and will mean that he can't access his storage if there are hardware changes (or he's running in a virtualized environment that has shifting MACs.)  Please set  SECRET_KEY  as soon as possible.  The recommended way is to set it as an environmental variable,  WILL_SECRET_KEY , in an environment that is secured and you trust.  Any string will work, and entropy is good.", 
            "title": "4. Set your encryption secret key."
        }, 
        {
            "location": "/upgrading_to_2/#5-set-the-new-20-settings-to-your-liking", 
            "text": "Will 2 ships with bunch of new features, and though we've provided sensible defaults, if you'd like, you can update your  config.py  with your preferences.  The simplest way to see everything is to have Will generate a  config.py.dist  that you can use for comparison:  $ generate_will_project --config-dist-only\n...\nCreated a config.py.dist.  Open it up to see what's new!  It's worth reading through the new  config.py , but here's a few areas specifically worth a look:", 
            "title": "5. Set the new 2.0 settings to your liking."
        }, 
        {
            "location": "/upgrading_to_2/#platform-and-decision-making", 
            "text": "As mentioned above, there are now multiple IO backends and platforms that Will can communicate on. It's also now easy to  write your own , pull requests are very welcome, and more are coming soon.  Here's all the options:  IO_BACKENDS = [\n     will.backends.io_adapters.slack ,\n     will.backends.io_adapters.hipchat ,\n     will.backends.io_adapters.rocketchat ,\n     will.backends.io_adapters.shell ,\n]  Will 2 also comes with pluggable brains - split into Analysis, Generation, and Execution backends.  The defaults are solid and behave similarly to Will 1.0 (the only difference is a high-confidence fuzzy matching engine), but if you're interested in making your Will more flexible, or adding more context to his responses, building  custom backends is easy .  Here's all of the options, with the defaults uncommented.   It's worth pulling this into your  config.py .  # Backends to analyze messages and generate useful metadata\nANALYZE_BACKENDS = [\n     will.backends.analysis.nothing ,\n     will.backends.analysis.history ,\n]\n\n# Backends to generate possible actions, and metadata about them.\nGENERATION_BACKENDS = [\n     will.backends.generation.strict_regex ,\n     will.backends.generation.fuzzy_all_matches ,\n    #  will.backends.generation.fuzzy_best_match ,\n]\n\n# The  decision making  backends that look among the generated choices,\n# and decide which to follow. Backends are executed in order, and any\n# backend can stop further evaluation.\nEXECUTION_BACKENDS = [\n     will.backends.execution.best_score ,\n    #  will.backends.execution.all ,\n]  There are also a few settings to tweak things like the fuzzy logic.  These have sensible defaults, but you can tweak them to your liking.  # Confidence fuzzy generation backends require before Will responds\n# https://pypi.python.org/pypi/fuzzywuzzy\nFUZZY_MINIMUM_MATCH_CONFIDENCE = 90  # Defaults to 90%\nFUZZY_REGEX_ALLOWABLE_ERRORS = 3", 
            "title": "Platform and Decision-making"
        }, 
        {
            "location": "/upgrading_to_2/#6-thats-it-let-us-know-how-it-goes", 
            "text": "That's all you really need to know to flip the switch to Will 2.0.    As there's a lot of new stuff in this release, it's possible that some bugs have slipped through the cracks.  Please submit anything you find, no matter how small,  into the github issue tracker .  We'll be active in fixing things ASAP and helping if you're stuck.  Thanks for using Will, and for going through the big upgrade!  We're excited about what the future holds, and happy to get your bots free from platform lock-in.  If you'd like to do a deeper dive into what's new, check out the documentation  on Will's new brain .", 
            "title": "6. That's it - let us know how it goes!"
        }, 
        {
            "location": "/plugins/basics/", 
            "text": "Teach your will awesome stuff\n\n\nYour will is all yours.  He'll come with all the great functions of the will library, but the power to teach him the things that are really useful to you is completely in your hands.\n\n\nWe've designed will to be the friendliest, easiest-to-teach bot anywhere, where even non-coders can hop in and add new functionality in a matter of minutes.  We hope you'll find him as friendly as we do!\n\n\n\n\nPlugin basics\n\n\nPlugins are just normal python files with at least one class that subclasses \nWillPlugin\n, and at least one method that's decorated. They can live anywhere normal python modules live, and will has some niceties to make organizing them simple.\n\n\nBut sometimes, the best way to learn is to dive right in - so let's make one!\n\n\nHello, world\n\n\nLet's start as simple as they come - a plugin for will to say hello.  Since he already comes with \"hello\", and \"hi\", in this example, we'll go with \"bonjour!\"\n\n\nStep 1: Create a bonjour.py\n\n\nThis file can be called anything, but given the functionality, bonjour seems like a fair name.  Create the file in your plugins folder:\n\n\n\n\nStep 2: Add the plugin python code\n\n\nIn the \nbonjour.py\n file, add this:\n\n\nfrom will.plugin import WillPlugin\nfrom will.decorators import respond_to, periodic, hear, randomly, route, rendered_template, require_settings\n\n\nclass BonjourPlugin(WillPlugin):\n\n    @respond_to(\nbonjour\n)\n    def say_bonjour_will(self, message):\n        \nbonjour: I know how to say bonjour! In French!\n\n        self.reply(\nbonjour!\n)\n\n\n\n\n\n\nStep 3: Restart your will\n\n\nFinally, \nctrl+c\n then restart your will to load the new plugin, and you should be able to do this:\n\n\n\n\nEasy, right?  Well, now that you've got your feet wet, let's see  \nwhat else will knows how to notice\n.", 
            "title": "The Basics"
        }, 
        {
            "location": "/plugins/basics/#teach-your-will-awesome-stuff", 
            "text": "Your will is all yours.  He'll come with all the great functions of the will library, but the power to teach him the things that are really useful to you is completely in your hands.  We've designed will to be the friendliest, easiest-to-teach bot anywhere, where even non-coders can hop in and add new functionality in a matter of minutes.  We hope you'll find him as friendly as we do!", 
            "title": "Teach your will awesome stuff"
        }, 
        {
            "location": "/plugins/basics/#plugin-basics", 
            "text": "Plugins are just normal python files with at least one class that subclasses  WillPlugin , and at least one method that's decorated. They can live anywhere normal python modules live, and will has some niceties to make organizing them simple.  But sometimes, the best way to learn is to dive right in - so let's make one!", 
            "title": "Plugin basics"
        }, 
        {
            "location": "/plugins/basics/#hello-world", 
            "text": "Let's start as simple as they come - a plugin for will to say hello.  Since he already comes with \"hello\", and \"hi\", in this example, we'll go with \"bonjour!\"", 
            "title": "Hello, world"
        }, 
        {
            "location": "/plugins/basics/#step-1-create-a-bonjourpy", 
            "text": "This file can be called anything, but given the functionality, bonjour seems like a fair name.  Create the file in your plugins folder:", 
            "title": "Step 1: Create a bonjour.py"
        }, 
        {
            "location": "/plugins/basics/#step-2-add-the-plugin-python-code", 
            "text": "In the  bonjour.py  file, add this:  from will.plugin import WillPlugin\nfrom will.decorators import respond_to, periodic, hear, randomly, route, rendered_template, require_settings\n\n\nclass BonjourPlugin(WillPlugin):\n\n    @respond_to( bonjour )\n    def say_bonjour_will(self, message):\n         bonjour: I know how to say bonjour! In French! \n        self.reply( bonjour! )", 
            "title": "Step 2: Add the plugin python code"
        }, 
        {
            "location": "/plugins/basics/#step-3-restart-your-will", 
            "text": "Finally,  ctrl+c  then restart your will to load the new plugin, and you should be able to do this:   Easy, right?  Well, now that you've got your feet wet, let's see   what else will knows how to notice .", 
            "title": "Step 3: Restart your will"
        }, 
        {
            "location": "/plugins/notice/", 
            "text": "What will can notice\n\n\nWill can notice a variety of things, and this list keeps growing.  When you want your will to pay attention to a particular thing, you'll use one of will's decorators - an example of each is below.\n\n\nRespond to direct mentions\n\n\nSimple enough - if you directly @will mention him in a message \nor\n send him a message in a 1-1 channel, he'll see these.  It's exactly what we used in the hello, world example.\n\n\n@respond_to(\nbonjour\n)\ndef say_bonjour_will(self, message):\n    # Awesome stuff\n\n\n\n\nYou can also use named matches in the regex:\n\n\n@respond_to(\naward (?P\nnum_stars\n\\d)+ gold stars? to (?P\nmention_name\n.*)\n)\ndef gold_stars(self, message, num_stars=1, mention_name=None):\n    # Fantastic gold-starness\n\n\n\n\n@respond_to\n takes a number of options:\n\n\n@respond_to(regex, include_me=False, case_sensitive=False, multiline=False, admin_only=False, acl=[])\n\n\n\n\n\n\nregex\n: a regular expression to match.  Any named matches are passed along as keyword arguments.\n\n\ninclude_me\n: whether will should include the things he says as possible matches\n\n\ncase_sensitive\n: should the regex be case sensitive?\n\n\nmultiline\n: should the regex allow multiline matches?\n\n\nadmin_only\n: only runs the command if the sender is specified as an administrator.\n\n\nacl\n: only runs the command if the sender is member of a specific ACL group. Any set is accepted as an argument.\n\n\n\n\n \n\n\nHear in any message\n\n\nSometimes, you want will to take actions when he sees things in everyday conversation, even if it wasn't directly addressed to him.  That's what \n@hear()\n is for.\n\n\n@hear(\n(?:ran into )?a bug\n)\ndef log_all_bugs(self, message):\n    # Awesome stuff\n\n\n\n\n@hear\n takes a the same options as \nrespond_to\n:\n\n\n@hear(regex, include_me=False, case_sensitive=False, multiline=False, admin_only=False, acl=[])\n\n\n\n\n\n\nregex\n: a regular expression to match.  Any named matches are passed along as keyword arguments.\n\n\ninclude_me\n: whether will should include the things he says as possible matches\n\n\ncase_sensitive\n: should the regex be case sensitive?\n\n\nmultiline\n: should the regex allow multiline matches?\n\n\nadmin_only\n: only runs the command if the sender is specified as an administrator.\n\n\nacl\n: only runs the command if the sender is member of a specific ACL group. Any set is accepted as an argument.\n\n\n\n\n \n\n\nTake an action on a schedule\n\n\nIt's one of the best things about robots - they never, ever forget.  Will's no exception.  The \n@periodic\n decorator makes scheduled tasks simple.\n\n\n@periodic(hour='10', minute='0', day_of_week=\nmon-fri\n)\ndef standup(self):\n    self.say(\n@all Standup! %s\n % settings.WILL_HANGOUT_URL)\n\n\n\n\nUnder the hood, \n@periodic\n uses \napscheduler\n to provide its options, so you can use any of the following as keyword arguments:\n\n\n\n\nyear\n: 4-digit year number\n\n\nmonth\n: month number (1-12)\n\n\nday\n: day of the month (1-31)\n\n\nweek\n: ISO week number (1-53)\n\n\nday_of_week\n: number or name of weekday (0-6 or mon,tue,wed,thu,fri,sat,sun)\n\n\nhour\n: hour (0-23)\n\n\nminute\n: minute (0-59)\n\n\nsecond\n: second (0-59)\n\n\n\n\nFor each of those keys, any of the following expressions are valid values:\n\n\n\n\n*\n (any): Fire on every value\n\n\n*/a\n (any): Fire every a values, starting from the minimum\n\n\na-b\n (any): Fire on any value within the a-b range (a must be smaller than b)\n\n\na-b/c\n (any): Fire every c values within the a-b range\n\n\nxth y\n (day): Fire on the x -th occurrence of weekday y within the month\n\n\nlast\n x\n (day): Fire on the last occurrence of weekday x within the month\n\n\nlast\n (day): Fire on the last day within the month\n\n\nx,y,z\n (any): Fire on any matching expression; can combine any number of any of the above expressions\n\n\n\n\nAwesome, right?\n\n\nHandle webhooks and web pages\n\n\nThat's right. Will's also a full-fledged webserver under the hood, thanks to \nbottle\n.  Using \n@route\n, he can handle webhooks, talk to chat, and render full HTML pages.\n\n\n# Simple\n@route(\n/ping\n)\ndef ping(self):\n    return \nPONG\n\n\n# Render a template with jinja\n@route(\n/keep-alive\n)\n@rendered_template(\nkeep_alive.html\n)\ndef keep_alive(self):\n    return {}\n\n# With full control, multiple templates, still connected to chat.\n@route(\n/complex_page/\npage_id:int\n, method=\nPOST\n)\ndef complex_page(self, page_id):\n    # Talk to chat\n    self.say(\nHey, somebody's loading the complex page.\n)\n    # Get JSON post data:\n    post_data = self.request.json\n\n    # Render templates\n    header = rendered_template(\nheader.html\n, post_data)\n    some_other_context = {\npage_id\n: page_id}\n    some_other_context[\nheader\n] = header\n    return rendered_template(\ncomplex_page.html\n, some_other_context)\n\n\n\n\nDo things randomly\n\n\nVariety is the spice of life, and nobody wants a robot without at least a \nlittle\n personality.  So, will's \n@randomly\n decorator allows you to specify actions that happen randomly, within a given window.\n\n\n@randomly(start_hour='10', end_hour='17', day_of_week=\nmon-fri\n, num_times_per_day=1)\ndef walkmaster(self):\n    self.say(\n@all time for a walk!\n)\n\n\n\n\n@randomly\n accepts a few arguments:\n\n\n@randomly(start_hour=0, end_hour=23, day_of_week=\n*\n, num_times_per_day=1):\n\n\n\n\n\n\nstart_hour\n:  When to start the random window.\n\n\nend_hour\n:  When to end the random window.\n\n\nday_of_week\n:  What days of the week is the window available? Parsed with \napscheduler\n.\n\n\nnum_times_per_day\n:  How many times per day within the window, should actions happen?\n\n\n\n\nNow that you've got a handle on the things will can notice, let's take a look at \nthe ways he can respond\n.", 
            "title": "What Will Can Notice"
        }, 
        {
            "location": "/plugins/notice/#what-will-can-notice", 
            "text": "Will can notice a variety of things, and this list keeps growing.  When you want your will to pay attention to a particular thing, you'll use one of will's decorators - an example of each is below.", 
            "title": "What will can notice"
        }, 
        {
            "location": "/plugins/notice/#respond-to-direct-mentions", 
            "text": "Simple enough - if you directly @will mention him in a message  or  send him a message in a 1-1 channel, he'll see these.  It's exactly what we used in the hello, world example.  @respond_to( bonjour )\ndef say_bonjour_will(self, message):\n    # Awesome stuff  You can also use named matches in the regex:  @respond_to( award (?P num_stars \\d)+ gold stars? to (?P mention_name .*) )\ndef gold_stars(self, message, num_stars=1, mention_name=None):\n    # Fantastic gold-starness  @respond_to  takes a number of options:  @respond_to(regex, include_me=False, case_sensitive=False, multiline=False, admin_only=False, acl=[])   regex : a regular expression to match.  Any named matches are passed along as keyword arguments.  include_me : whether will should include the things he says as possible matches  case_sensitive : should the regex be case sensitive?  multiline : should the regex allow multiline matches?  admin_only : only runs the command if the sender is specified as an administrator.  acl : only runs the command if the sender is member of a specific ACL group. Any set is accepted as an argument.", 
            "title": "Respond to direct mentions"
        }, 
        {
            "location": "/plugins/notice/#hear-in-any-message", 
            "text": "Sometimes, you want will to take actions when he sees things in everyday conversation, even if it wasn't directly addressed to him.  That's what  @hear()  is for.  @hear( (?:ran into )?a bug )\ndef log_all_bugs(self, message):\n    # Awesome stuff  @hear  takes a the same options as  respond_to :  @hear(regex, include_me=False, case_sensitive=False, multiline=False, admin_only=False, acl=[])   regex : a regular expression to match.  Any named matches are passed along as keyword arguments.  include_me : whether will should include the things he says as possible matches  case_sensitive : should the regex be case sensitive?  multiline : should the regex allow multiline matches?  admin_only : only runs the command if the sender is specified as an administrator.  acl : only runs the command if the sender is member of a specific ACL group. Any set is accepted as an argument.", 
            "title": "Hear in any message"
        }, 
        {
            "location": "/plugins/notice/#take-an-action-on-a-schedule", 
            "text": "It's one of the best things about robots - they never, ever forget.  Will's no exception.  The  @periodic  decorator makes scheduled tasks simple.  @periodic(hour='10', minute='0', day_of_week= mon-fri )\ndef standup(self):\n    self.say( @all Standup! %s  % settings.WILL_HANGOUT_URL)  Under the hood,  @periodic  uses  apscheduler  to provide its options, so you can use any of the following as keyword arguments:   year : 4-digit year number  month : month number (1-12)  day : day of the month (1-31)  week : ISO week number (1-53)  day_of_week : number or name of weekday (0-6 or mon,tue,wed,thu,fri,sat,sun)  hour : hour (0-23)  minute : minute (0-59)  second : second (0-59)   For each of those keys, any of the following expressions are valid values:   *  (any): Fire on every value  */a  (any): Fire every a values, starting from the minimum  a-b  (any): Fire on any value within the a-b range (a must be smaller than b)  a-b/c  (any): Fire every c values within the a-b range  xth y  (day): Fire on the x -th occurrence of weekday y within the month  last  x  (day): Fire on the last occurrence of weekday x within the month  last  (day): Fire on the last day within the month  x,y,z  (any): Fire on any matching expression; can combine any number of any of the above expressions   Awesome, right?", 
            "title": "Take an action on a schedule"
        }, 
        {
            "location": "/plugins/notice/#handle-webhooks-and-web-pages", 
            "text": "That's right. Will's also a full-fledged webserver under the hood, thanks to  bottle .  Using  @route , he can handle webhooks, talk to chat, and render full HTML pages.  # Simple\n@route( /ping )\ndef ping(self):\n    return  PONG \n\n# Render a template with jinja\n@route( /keep-alive )\n@rendered_template( keep_alive.html )\ndef keep_alive(self):\n    return {}\n\n# With full control, multiple templates, still connected to chat.\n@route( /complex_page/ page_id:int , method= POST )\ndef complex_page(self, page_id):\n    # Talk to chat\n    self.say( Hey, somebody's loading the complex page. )\n    # Get JSON post data:\n    post_data = self.request.json\n\n    # Render templates\n    header = rendered_template( header.html , post_data)\n    some_other_context = { page_id : page_id}\n    some_other_context[ header ] = header\n    return rendered_template( complex_page.html , some_other_context)", 
            "title": "Handle webhooks and web pages"
        }, 
        {
            "location": "/plugins/notice/#do-things-randomly", 
            "text": "Variety is the spice of life, and nobody wants a robot without at least a  little  personality.  So, will's  @randomly  decorator allows you to specify actions that happen randomly, within a given window.  @randomly(start_hour='10', end_hour='17', day_of_week= mon-fri , num_times_per_day=1)\ndef walkmaster(self):\n    self.say( @all time for a walk! )  @randomly  accepts a few arguments:  @randomly(start_hour=0, end_hour=23, day_of_week= * , num_times_per_day=1):   start_hour :  When to start the random window.  end_hour :  When to end the random window.  day_of_week :  What days of the week is the window available? Parsed with  apscheduler .  num_times_per_day :  How many times per day within the window, should actions happen?   Now that you've got a handle on the things will can notice, let's take a look at  the ways he can respond .", 
            "title": "Do things randomly"
        }, 
        {
            "location": "/plugins/reply/", 
            "text": "How will can respond\n\n\nWill can respond in a variety of ways, and since he's pure python, your imagination is the limit.\n\n\nTalk to the room\n\n\nLike any normal person, will can talk to the chat room, or in 1-1 chats.  To talk to the room in your plugins, you'll want to use the \nself.say()\n method.\n\n\n@respond_to(\nbonjour\n)\ndef say_bonjour_will(self, message):\n    # Awesome stuff\n    self.say(\nBonjour!\n)\n\n\n\n\n\n\nsay()\n comes with a number of options, including color, html, and ping notify. \n\n\nself.say(content, channel=None, html=False, color=\ngreen\n, notify=False)\n\n\n\n\n\n\ncontent\n: the content you want to send to the room. Any string will do, HTML or plain text.\n\n\nchannel\n: (optional) The name of the channel or room to send the message to.  If not specified, Will is smart, and will just reply in the same channel/room/thread.\n\n\nservice\n: (optional, rare) The name of the service (i.e. 'slack', 'hipchat', 'rocketchat') you want to send the message on.  By default Will replies on the same service you contacted him on.\n\n\nhtml\n: if the message is HTML. \nTrue\n or \nFalse\n.\n\n\ncolor\n: (chat room only) the hipchat color to send. \"yellow\", \"red\", \"green\", \"purple\", \"gray\", or \"random\". Default is \"green\". \n\n\nnotify\n: whether the message should trigger a 'ping' notification. \nTrue\n or \nFalse\n.\n\n\n\n\nReply with a mention\n\n\nSometimes you want will to ping you - that's where @name mentions are great.  To do those in will, you'll want to use \nself.reply()\n\n\n@respond_to(\n^hi\n)   # Basic\ndef hi(self, message):\n    self.reply(\nhello, %s!\n % message.sender.handle)\n\n\n\n\n\n\nAll the options: \n\n\nself.reply(content, html=False, color=\ngreen\n, notify=False, start_thread=False)\n\n\n\n\n\n\ncontent\n: the content you want to send to the room. HTML or plain text.\n\n\nhtml\n: if the message is HTML. \nTrue\n or \nFalse\n.\n\n\ncolor\n: (chat room only) the hipchat color to send. \"yellow\", \"red\", \"green\", \"purple\", \"gray\", or \"random\". Default is \"green\".\n\n\nnotify\n: whether the message should trigger a 'ping' notification. \nTrue\n or \nFalse\n.\n\n\nstart_thread\n: whether Will should start a new thread, if the backend supports it.\n\n\n\n\nTalk to the room from a webhook\n\n\nWhen will recieves messages from webhooks and HTTP requests, he's still connected to chat, and you can use \n.say()\n. By default, he'll speak to \nDEFAULT_ROOM\n.\n\n\n@route(\n/ping\n)\ndef ping(self):\n    self.say(\nPONG!\n)\n    # or\n    self.say(\nPONG!\n, room=\nping-pong\n, service=\nslack\n)\n\n\n\n\nIf you want to talk to a different room, you can pass in the \nchannel\n with the name of the channel or room you want to talk to.  If you have multiple services connected, just pass \nservice\n with the one you want.\n\n\nSend an email\n\n\nWill has one email backend at the moment, via \nmailgun\n.  If you've set \nDEFAULT_FROM_EMAIL\n, \nMAILGUN_API_URL\n, and \nMAILGUN_API_KEY\n, you can use \nself.send_email()\n\n\n@respond_to(\nstatus report\n)\ndef send_status_report(self):\n    self.send_email(email_list=['jill@example.com'], subject=\nHere's the latest report\n, message=rendered_template(\nreport.html\n, {}))\n\n\n\n\nHere's all the options:\n\n\nself.send_email(from_email=None, email_list=[], subject=\n, message=\n)\n\n\n\n\n\n\nfrom_email\n: (Optional) The email address the message should come from. Defaults to \nDEFAULT_FROM_EMAIL\n.\n\n\nemail_list\n: The list of addresses to send to.\n\n\nsubject\n: (Optional) The email subject.\n\n\nmessage\n: (Optional) The email body.\n\n\n\n\nSchedule a reply for the future\n\n\nSometimes, you want will to make plans for the future.  That's where \nself.schedule_say()\n comes in handy.\n\n\n@randomly(start_hour='10', end_hour='17', day_of_week=\nmon-fri\n, num_times_per_day=1)\ndef walkmaster(self):\n    now = datetime.datetime.now()\n    in_5_minutes = now + datetime.timedelta(minutes=5)\n\n    self.say(\n@all Walk happening in 5 minutes!\n)\n    self.schedule_say(\n@all It's walk time!\n, in_5_minutes)\n\n\n\n\nThe options are pretty much the same as \nself.say\n, with the addition of the \nwhen\n parameter.\n\n\nself.schedule_say(content, when, message=None, channel=None, html=False, color=\ngreen\n, notify=False)\n\n\n\n\n\n\ncontent\n: the content you want to send to the room. Any string will do, HTML or plain text.\n\n\nwhen\n: when you want the message to be said. Python \ndatetime\n object.\n\n\nmessage\n: (optional) The incoming message object\n\n\nchannel\n: (optional) The name of the channel or room to send the message to.  If not specified, Will is smart, and will just reply in the same channel/room/thread. You can also pass \"ALL_ROOMS\" to send the message everywhere, if that's really your thing.\n\n\nservice\n: (optional, rare) The name of the service (i.e. 'slack', 'hipchat', 'rocketchat') you want to send the message on.  By default Will replies on the same service you contacted him on.\n\n\nhtml\n: if the message is HTML. \nTrue\n or \nFalse\n.\n\n\ncolor\n: (chat room only) the hipchat color to send. \"yellow\", \"red\", \"green\", \"purple\", \"gray\", or \"random\". Default is \"green\".\n\n\nnotify\n: whether the message should trigger a 'ping' notification. \nTrue\n or \nFalse\n.\n\n\n\n\nSet the topic\n\n\nSometimes, it's good to give the conversation some direction.  Will can set the topic in hipchat using \nself.set_topic()\n\n\nimport requests\n\n@respond_to(\nnew topic\n)\ndef give_us_somethin_to_talk_about(self, message):\n    r = requests.get(\nhttp://chatoms.com/chatom.json?Normal=1\nFun=2\nPhilosophy=3\nOut+There=4\n)\n    data = r.json()\n    self.set_topic(data[\ntext\n], message=message)\n\n\n\n\nNote: you can't set the topic of a 1-1 chat. Will will complain politely.  All options:\n\n\nself.set_topic(topic, message=None, channel=None) \n\n\n\n\n\n\ntopic\n: The string you want to set the topic to\n\n\nmessage\n: (optional) The incoming message object\n\n\nchannel\n: (optional) The name of the channel or room to send the message to.  If not specified, Will is smart, and will just set the topic for the same channel/room/thread. You can also pass \"ALL_ROOMS\" to send the message everywhere, if that's really your thing.\n\n\nservice\n: (optional, rare) The name of the service you want to send the message on.  By default Will replies on the same service you contacted him on.\n\n\n\n\nDo any python thing\n\n\nWill is Just Python.  Because of that, your imagination is the limit of what he can do to respond to requests.\n\n\nHere's a few things our will does, every day:\n\n\n\n\nSpins up and tears down staging stacks,\n\n\nMonitors uptime on our production sites, and contacts the on-call developer if things go down,\n\n\nKeeps track of code reviews on pending branches,\n\n\nAdd new signups to our CRM,\n\n\nStarts our daily standup video chat,\n\n\nAnd the list goes on.\n\n\n\n\nWill is open-source, and PRs are very welcome.  If someone wants to write \nself.send_sms()\n, or anything else, it's all yours!\n\n\nReady to make some plugins?  Check out \nhow to create and organize plugins\n.", 
            "title": "How Will Can Respond"
        }, 
        {
            "location": "/plugins/reply/#how-will-can-respond", 
            "text": "Will can respond in a variety of ways, and since he's pure python, your imagination is the limit.", 
            "title": "How will can respond"
        }, 
        {
            "location": "/plugins/reply/#talk-to-the-room", 
            "text": "Like any normal person, will can talk to the chat room, or in 1-1 chats.  To talk to the room in your plugins, you'll want to use the  self.say()  method.  @respond_to( bonjour )\ndef say_bonjour_will(self, message):\n    # Awesome stuff\n    self.say( Bonjour! )   say()  comes with a number of options, including color, html, and ping notify.   self.say(content, channel=None, html=False, color= green , notify=False)   content : the content you want to send to the room. Any string will do, HTML or plain text.  channel : (optional) The name of the channel or room to send the message to.  If not specified, Will is smart, and will just reply in the same channel/room/thread.  service : (optional, rare) The name of the service (i.e. 'slack', 'hipchat', 'rocketchat') you want to send the message on.  By default Will replies on the same service you contacted him on.  html : if the message is HTML.  True  or  False .  color : (chat room only) the hipchat color to send. \"yellow\", \"red\", \"green\", \"purple\", \"gray\", or \"random\". Default is \"green\".   notify : whether the message should trigger a 'ping' notification.  True  or  False .", 
            "title": "Talk to the room"
        }, 
        {
            "location": "/plugins/reply/#reply-with-a-mention", 
            "text": "Sometimes you want will to ping you - that's where @name mentions are great.  To do those in will, you'll want to use  self.reply()  @respond_to( ^hi )   # Basic\ndef hi(self, message):\n    self.reply( hello, %s!  % message.sender.handle)   All the options:   self.reply(content, html=False, color= green , notify=False, start_thread=False)   content : the content you want to send to the room. HTML or plain text.  html : if the message is HTML.  True  or  False .  color : (chat room only) the hipchat color to send. \"yellow\", \"red\", \"green\", \"purple\", \"gray\", or \"random\". Default is \"green\".  notify : whether the message should trigger a 'ping' notification.  True  or  False .  start_thread : whether Will should start a new thread, if the backend supports it.", 
            "title": "Reply with a mention"
        }, 
        {
            "location": "/plugins/reply/#talk-to-the-room-from-a-webhook", 
            "text": "When will recieves messages from webhooks and HTTP requests, he's still connected to chat, and you can use  .say() . By default, he'll speak to  DEFAULT_ROOM .  @route( /ping )\ndef ping(self):\n    self.say( PONG! )\n    # or\n    self.say( PONG! , room= ping-pong , service= slack )  If you want to talk to a different room, you can pass in the  channel  with the name of the channel or room you want to talk to.  If you have multiple services connected, just pass  service  with the one you want.", 
            "title": "Talk to the room from a webhook"
        }, 
        {
            "location": "/plugins/reply/#send-an-email", 
            "text": "Will has one email backend at the moment, via  mailgun .  If you've set  DEFAULT_FROM_EMAIL ,  MAILGUN_API_URL , and  MAILGUN_API_KEY , you can use  self.send_email()  @respond_to( status report )\ndef send_status_report(self):\n    self.send_email(email_list=['jill@example.com'], subject= Here's the latest report , message=rendered_template( report.html , {}))  Here's all the options:  self.send_email(from_email=None, email_list=[], subject= , message= )   from_email : (Optional) The email address the message should come from. Defaults to  DEFAULT_FROM_EMAIL .  email_list : The list of addresses to send to.  subject : (Optional) The email subject.  message : (Optional) The email body.", 
            "title": "Send an email"
        }, 
        {
            "location": "/plugins/reply/#schedule-a-reply-for-the-future", 
            "text": "Sometimes, you want will to make plans for the future.  That's where  self.schedule_say()  comes in handy.  @randomly(start_hour='10', end_hour='17', day_of_week= mon-fri , num_times_per_day=1)\ndef walkmaster(self):\n    now = datetime.datetime.now()\n    in_5_minutes = now + datetime.timedelta(minutes=5)\n\n    self.say( @all Walk happening in 5 minutes! )\n    self.schedule_say( @all It's walk time! , in_5_minutes)  The options are pretty much the same as  self.say , with the addition of the  when  parameter.  self.schedule_say(content, when, message=None, channel=None, html=False, color= green , notify=False)   content : the content you want to send to the room. Any string will do, HTML or plain text.  when : when you want the message to be said. Python  datetime  object.  message : (optional) The incoming message object  channel : (optional) The name of the channel or room to send the message to.  If not specified, Will is smart, and will just reply in the same channel/room/thread. You can also pass \"ALL_ROOMS\" to send the message everywhere, if that's really your thing.  service : (optional, rare) The name of the service (i.e. 'slack', 'hipchat', 'rocketchat') you want to send the message on.  By default Will replies on the same service you contacted him on.  html : if the message is HTML.  True  or  False .  color : (chat room only) the hipchat color to send. \"yellow\", \"red\", \"green\", \"purple\", \"gray\", or \"random\". Default is \"green\".  notify : whether the message should trigger a 'ping' notification.  True  or  False .", 
            "title": "Schedule a reply for the future"
        }, 
        {
            "location": "/plugins/reply/#set-the-topic", 
            "text": "Sometimes, it's good to give the conversation some direction.  Will can set the topic in hipchat using  self.set_topic()  import requests\n\n@respond_to( new topic )\ndef give_us_somethin_to_talk_about(self, message):\n    r = requests.get( http://chatoms.com/chatom.json?Normal=1 Fun=2 Philosophy=3 Out+There=4 )\n    data = r.json()\n    self.set_topic(data[ text ], message=message)  Note: you can't set the topic of a 1-1 chat. Will will complain politely.  All options:  self.set_topic(topic, message=None, channel=None)    topic : The string you want to set the topic to  message : (optional) The incoming message object  channel : (optional) The name of the channel or room to send the message to.  If not specified, Will is smart, and will just set the topic for the same channel/room/thread. You can also pass \"ALL_ROOMS\" to send the message everywhere, if that's really your thing.  service : (optional, rare) The name of the service you want to send the message on.  By default Will replies on the same service you contacted him on.", 
            "title": "Set the topic"
        }, 
        {
            "location": "/plugins/reply/#do-any-python-thing", 
            "text": "Will is Just Python.  Because of that, your imagination is the limit of what he can do to respond to requests.  Here's a few things our will does, every day:   Spins up and tears down staging stacks,  Monitors uptime on our production sites, and contacts the on-call developer if things go down,  Keeps track of code reviews on pending branches,  Add new signups to our CRM,  Starts our daily standup video chat,  And the list goes on.   Will is open-source, and PRs are very welcome.  If someone wants to write  self.send_sms() , or anything else, it's all yours!  Ready to make some plugins?  Check out  how to create and organize plugins .", 
            "title": "Do any python thing"
        }, 
        {
            "location": "/plugins/create/", 
            "text": "Creating and Organizing plugins\n\n\nWe've designed will to be able to scale from small, personal installs to big, corporate robots.  Here's the best practices on creating and organizing your plugins.\n\n\nWhere do plugins live?\n\n\nSince plugins are just python files, they can live anywhere on the \nPYTHONPATH\n.  Will will look for plugins anywhere on the system \nPYTHONPATH\n, and automatically adds \nwill/plugins\n and \nyour_will/plugins\n to the path.\n\n\nHow do I specify which plugins to load?\n\n\nThe list of plugins to load lives in \nconfig.py\n, as well as a blacklist of plugins that, even if they're on the path, should be ignored.\n\n\nWhen given a module, will imports it, then \nrecursively loads\n all plugins found within it.\n\n\nBoth \nPLUGINS\n and \nPLUGINS_BLACKLIST\n can contain:\n\n\nBuilt-in will plugins, e.g.:\n\n\n\n\nAll built-in modules: \nwill.plugins\n\n\nBuilt-in modules: \nwill.plugins.module_name\n\n\nSpecific plugins: \nwill.plugins.module_name.plugin\n\n\n\n\nPlugins in your will, e.g.:\n\n\n\n\nAll modules: \nplugins\n\n\nA specific module: \nplugins.module_name\n\n\nSpecific plugins: \nplugins.module_name.plugin\n\n\n\n\nPlugins anywhere else on your PYTHONPATH, e.g.:\n\n\n\n\nAll modules: \nsomeapp\n\n\nA specific module: \nsomeapp.module_name\n\n\nSpecific plugins: \nsomeapp.module_name.plugin\n\n\n\n\nHere's the corresponding section of \nconfig.py\n, by default:\n\n\nPLUGINS = [\n    # Built-ins\n    \nwill.plugins.admin\n,\n    \nwill.plugins.chat_room\n,\n    \nwill.plugins.devops\n,\n    \nwill.plugins.friendly\n,\n    \nwill.plugins.help\n,\n    \nwill.plugins.productivity\n,\n    \nwill.plugins.web\n,\n\n    # All plugins in your project.\n    \nplugins\n,\n]\n\n# Don't load any of the plugins in this list.  Same options as above.\nPLUGIN_BLACKLIST = [\n    # \nwill.plugins.friendly.cookies\n,      # But who would deprive will of cookies??\n]\n\n\n\n\nWhat exactly is a plugin?\n\n\nA plugin is just a python file with at least one class that subclasses \nWillPlugin\n, and at least one method that's decorated with \none of will's listen decorators\n.\n\n\nFor example:\n\n\nping.py\n\n\nfrom will.plugin import WillPlugin\nfrom will.decorators import respond_to, periodic, hear, randomly, route, rendered_template, require_settings\n\n\nclass PingPlugin(WillPlugin):\n\n    @respond_to(\n^ping$\n)\n    def ping(self, message):\n        self.reply(\nPONG\n)\n\n\n\n\nWhat's a module?\n\n\nModules are a way to group similar plugins.\n\n\nStructurally, a will module is just a python module: a folder with an \n__init__.py\n.\n\n\n\n\nThat's it.\n\n\nWhat about that awesome help text?\n\n\nGlad you asked.  The help text comes from a special variable, expected to be in \n__init__.py\n: \n\n\n__init__.py\n\n\nMODULE_DESCRIPTION = \nOld-fashioned friendliness\n\n\n\n\n\nWhen help runs, plugins are grouped according to their \nMODULE_DESCRIPTION\n, which means you can have physically distinct modules that share the same help grouping.\n\n\n\n\nEasy, right?  Awesome. Now that you know where to put them, take a look at the \nbuilt-in features on WillPlugin\n.", 
            "title": "Creating and Organizing Plugins"
        }, 
        {
            "location": "/plugins/create/#creating-and-organizing-plugins", 
            "text": "We've designed will to be able to scale from small, personal installs to big, corporate robots.  Here's the best practices on creating and organizing your plugins.", 
            "title": "Creating and Organizing plugins"
        }, 
        {
            "location": "/plugins/create/#where-do-plugins-live", 
            "text": "Since plugins are just python files, they can live anywhere on the  PYTHONPATH .  Will will look for plugins anywhere on the system  PYTHONPATH , and automatically adds  will/plugins  and  your_will/plugins  to the path.", 
            "title": "Where do plugins live?"
        }, 
        {
            "location": "/plugins/create/#how-do-i-specify-which-plugins-to-load", 
            "text": "The list of plugins to load lives in  config.py , as well as a blacklist of plugins that, even if they're on the path, should be ignored.  When given a module, will imports it, then  recursively loads  all plugins found within it.  Both  PLUGINS  and  PLUGINS_BLACKLIST  can contain:  Built-in will plugins, e.g.:   All built-in modules:  will.plugins  Built-in modules:  will.plugins.module_name  Specific plugins:  will.plugins.module_name.plugin   Plugins in your will, e.g.:   All modules:  plugins  A specific module:  plugins.module_name  Specific plugins:  plugins.module_name.plugin   Plugins anywhere else on your PYTHONPATH, e.g.:   All modules:  someapp  A specific module:  someapp.module_name  Specific plugins:  someapp.module_name.plugin   Here's the corresponding section of  config.py , by default:  PLUGINS = [\n    # Built-ins\n     will.plugins.admin ,\n     will.plugins.chat_room ,\n     will.plugins.devops ,\n     will.plugins.friendly ,\n     will.plugins.help ,\n     will.plugins.productivity ,\n     will.plugins.web ,\n\n    # All plugins in your project.\n     plugins ,\n]\n\n# Don't load any of the plugins in this list.  Same options as above.\nPLUGIN_BLACKLIST = [\n    #  will.plugins.friendly.cookies ,      # But who would deprive will of cookies??\n]", 
            "title": "How do I specify which plugins to load?"
        }, 
        {
            "location": "/plugins/create/#what-exactly-is-a-plugin", 
            "text": "A plugin is just a python file with at least one class that subclasses  WillPlugin , and at least one method that's decorated with  one of will's listen decorators .  For example:  ping.py  from will.plugin import WillPlugin\nfrom will.decorators import respond_to, periodic, hear, randomly, route, rendered_template, require_settings\n\n\nclass PingPlugin(WillPlugin):\n\n    @respond_to( ^ping$ )\n    def ping(self, message):\n        self.reply( PONG )", 
            "title": "What exactly is a plugin?"
        }, 
        {
            "location": "/plugins/create/#whats-a-module", 
            "text": "Modules are a way to group similar plugins.  Structurally, a will module is just a python module: a folder with an  __init__.py .   That's it.", 
            "title": "What's a module?"
        }, 
        {
            "location": "/plugins/create/#what-about-that-awesome-help-text", 
            "text": "Glad you asked.  The help text comes from a special variable, expected to be in  __init__.py :   __init__.py  MODULE_DESCRIPTION =  Old-fashioned friendliness   When help runs, plugins are grouped according to their  MODULE_DESCRIPTION , which means you can have physically distinct modules that share the same help grouping.   Easy, right?  Awesome. Now that you know where to put them, take a look at the  built-in features on WillPlugin .", 
            "title": "What about that awesome help text?"
        }, 
        {
            "location": "/plugins/builtins/", 
            "text": "Plugin Builtins\n\n\nWill's \nWillPlugin\n class packs in lots of useful functionality to make writing powerful plugins simple.  Let's go through it.\n\n\nStorage\n\n\nWill can remember almost any python object (using \ndill\n), even across reboots.\n\n\nIt's as simple as:\n\n\nself.save(\nmy_key\n, \nmy_value\n)\nself.load(\nmy_key\n, \ndefault value\n)\nself.append(\nmy_key\n, \nvalue\n)\nself.pop(\nmy_key\n, \nvalue\n)\n\n\n\n\nYou can also save a value temporarily by setting the number of seconds before it expires:\n\n\nself.save(\nmy_key\n, \nmy_value\n, expire=10)\n\n\n\n\nTemplate rendering\n\n\nWill includes \nJinja\n for powerful awesome template rendering.  To use it, just call \nself.rendered_template()\n\n\nself.rendered_template(template_name, context={}, custom_filters=[])\n\n\n\n\n\n\ntemplate_name\n: path to the template, relative to the \nTEMPLATE_DIRS\n specified in \nconfig.py\n.\n\n\ncontext\n: a dictionary to render the template with.\n\n\ncustom_filters\n: \ncustom filters\n  support for rendering templates\n\n\n\n\nYou can use \nrendered_template()\n directly in a plugin,\n\n\n@respond_to(\nwhat are the rooms\\?\n)\ndef list_rooms(self, message):\n    \nwhat are the rooms?: List all the rooms I know about.\n\n    context = {\nrooms\n: self.available_rooms.values(),}\n    self.say(rendered_template(\nrooms.html\n, context), message=message, html=True)\n\n\n\n\nOr, you can stack it as a decorator.\n\n\n@route(\n/\n)\n@rendered_template(\nhome.html\n)\ndef homepage_listener(self):\n    return {}\n\n\n\n\nA note on \nTEMPLATE_DIRS\n - Will automatically includes the following:\n\n\n\n\nCore Will's \ntemplates\n directory,\n\n\nYour Will's \ntemplates\n directory,\n\n\nAll \ntemplates\n directories in the root of modules specified in \nsettings.PLUGINS\n.\n\n\n\n\nHelp and documentation\n\n\nJust include a docstring, and your command will be included in @will help:\n\n\nclass BonjourPlugin(WillPlugin):\n\n    @respond_to(\nbonjour\n)\n    def say_bonjour_will(self, message):\n        \nbonjour: I know how to say bonjour! In French!\n\n        self.reply(\nbonjour!\n)\n\n\n\n\n\n\nIf you've \norganized your plugins in a module\n, your plugin's help text will be grouped by module.\n\n\n\n\nAccess Control\n\n\nYou can restrict certain actions to particular groups, by using will's access control list (ACL) support.\n\n\nUsage\n\n\nTo use ACL, you simply specify ACL groups and the relevant handles in your \nconfig.py\n, then pass \nacl=[]\n into any relevant \n@respond_to\ns or \n@hear\ns. \n\n\nHere's an example with an ops team, and an admin team:\n\n\n# config.py\n\nACL = {\n    \nops\n: [\nsteven\n, \nlevi\n, \nsusan\n],\n    \nadmins\n: [\nwooh\n],\n}\n\n\n\n\nThen, in your listeners:\n\n\n# Allow the ops and admins groups to stop EC2 instances,\n# but only allow admins to terminate the instances.\n\n@respond_to(\nec2 instance stop (?P\ninstance_id\n.*)\n, acl=[\nops\n, \nadmins\n])\ndef stop_ec2_instance(self, message, instance_id):\n    # do AWS stuff\n\n@respond_to(\nec2 instance terminate (?P\ninstance_id\n.*)\n, acl=[\nadmins\n])\ndef terminate_ec2_instance(self, message, instance_id):\n    # do AWS stuff\n\n\n\n\nComplex ACL behaviors, simple as that.\n\n\nAccess settings and config\n\n\nWill takes care of passing in environment variables and config via the \nsettings\n module.  To use it:\n\n\nconfig.py:\n\n\nHELLO_MESSAGE = \nBonjour from config.py\n\n\n\n\n\nor, on the shell:\n\n\n# note the `WILL_` prefix\nexport WILL_HELLO_MESSSAGE=\nBonjour from the environment\n\n\n\n\n\nthen, in any plugin: \n\n\nfrom will import settings\n\nclass BonjourPlugin(WillPlugin):\n\n    @respond_to(\nbonjour\n)\n    def say_bonjour_will(self, message):\n        self.reply(settings.HELLO_MESSAGE)\n\n\n\n\nYou can also mark one or more settings as required for your plugin with the \nrequire_settings\n decorator, and they'll be checked on startup.\n\n\nfrom will import settings\n\nclass BonjourPlugin(WillPlugin):\n\n    @require_settings(\nHELLO_MESSAGE\n, \nANOTHER_SETTING\n)\n    @respond_to(\nbonjour\n)\n    def say_bonjour_will(self, message):\n        self.reply(settings.HELLO_MESSAGE)\n\n\n\n\nWhen will starts up, he'll make sure they've been set:\n\n\n\n\nGetting a room's history\n\n\nSometimes you'll want to retrieve a room's history. No problem - get the room's object, and the last 20 messages are sitting on \nanalysis.history\n.\n\n\nclass HistoryPlugin(WillPlugin):\n\n    @respond_to(\n^get last message\n)\n    def get_history(self, message):\n        room = self.get_room_from_message(message)\n        self.reply(room.analysis[\nhistory\n][-1])\n\n\n\n\nParse natural time\n\n\nOften, it's useful to be able to talk to will about time in natural language.  To make that easy, will includes the helper functions built on \nparsedatetime\n and \nnatural\n: \nself.parse_natural_time\n and \nself.to_natural_day_and_time\n.\n\n\nparse_natural_time\n\n\nself.parse_natural_time(time_string)\n parses a textual time string, and returns a \ndatetime\n object.\n\n\n@respond_to(\nremind me on (?P\nremind_time\n.*)\n)\ndef remind_me_at(self, message, remind_time=None):\n    parsed_time = self.parse_natural_time(remind_time)\n\n\n\n\n\n\nto_natural_day_and_time\n\n\nself.to_natural_day_and_time(my_datetime)\n converts a python \ndatetime\n into a human-friendly string.\n\n\n@respond_to(\nshow_reminders\n)\ndef remind_me_at(self, message, remind_time=None):\n    reminders = self.load(\nreminders\n)\n    for r in reminders:\n        natural_time = self.to_natural_day_and_time(r)\n        self.say(\nOn %s\n % natural_time)\n\n\n\n\nNow you've got the hang of how to write your own plugins - but before you reinvent the wheel, take a look at \nwhat plugins are included in will\n!", 
            "title": "Plugin Builtins"
        }, 
        {
            "location": "/plugins/builtins/#plugin-builtins", 
            "text": "Will's  WillPlugin  class packs in lots of useful functionality to make writing powerful plugins simple.  Let's go through it.", 
            "title": "Plugin Builtins"
        }, 
        {
            "location": "/plugins/builtins/#storage", 
            "text": "Will can remember almost any python object (using  dill ), even across reboots.  It's as simple as:  self.save( my_key ,  my_value )\nself.load( my_key ,  default value )\nself.append( my_key ,  value )\nself.pop( my_key ,  value )  You can also save a value temporarily by setting the number of seconds before it expires:  self.save( my_key ,  my_value , expire=10)", 
            "title": "Storage"
        }, 
        {
            "location": "/plugins/builtins/#template-rendering", 
            "text": "Will includes  Jinja  for powerful awesome template rendering.  To use it, just call  self.rendered_template()  self.rendered_template(template_name, context={}, custom_filters=[])   template_name : path to the template, relative to the  TEMPLATE_DIRS  specified in  config.py .  context : a dictionary to render the template with.  custom_filters :  custom filters   support for rendering templates   You can use  rendered_template()  directly in a plugin,  @respond_to( what are the rooms\\? )\ndef list_rooms(self, message):\n     what are the rooms?: List all the rooms I know about. \n    context = { rooms : self.available_rooms.values(),}\n    self.say(rendered_template( rooms.html , context), message=message, html=True)  Or, you can stack it as a decorator.  @route( / )\n@rendered_template( home.html )\ndef homepage_listener(self):\n    return {}  A note on  TEMPLATE_DIRS  - Will automatically includes the following:   Core Will's  templates  directory,  Your Will's  templates  directory,  All  templates  directories in the root of modules specified in  settings.PLUGINS .", 
            "title": "Template rendering"
        }, 
        {
            "location": "/plugins/builtins/#help-and-documentation", 
            "text": "Just include a docstring, and your command will be included in @will help:  class BonjourPlugin(WillPlugin):\n\n    @respond_to( bonjour )\n    def say_bonjour_will(self, message):\n         bonjour: I know how to say bonjour! In French! \n        self.reply( bonjour! )   If you've  organized your plugins in a module , your plugin's help text will be grouped by module.", 
            "title": "Help and documentation"
        }, 
        {
            "location": "/plugins/builtins/#access-control", 
            "text": "You can restrict certain actions to particular groups, by using will's access control list (ACL) support.", 
            "title": "Access Control"
        }, 
        {
            "location": "/plugins/builtins/#usage", 
            "text": "To use ACL, you simply specify ACL groups and the relevant handles in your  config.py , then pass  acl=[]  into any relevant  @respond_to s or  @hear s.   Here's an example with an ops team, and an admin team:  # config.py\n\nACL = {\n     ops : [ steven ,  levi ,  susan ],\n     admins : [ wooh ],\n}  Then, in your listeners:  # Allow the ops and admins groups to stop EC2 instances,\n# but only allow admins to terminate the instances.\n\n@respond_to( ec2 instance stop (?P instance_id .*) , acl=[ ops ,  admins ])\ndef stop_ec2_instance(self, message, instance_id):\n    # do AWS stuff\n\n@respond_to( ec2 instance terminate (?P instance_id .*) , acl=[ admins ])\ndef terminate_ec2_instance(self, message, instance_id):\n    # do AWS stuff  Complex ACL behaviors, simple as that.", 
            "title": "Usage"
        }, 
        {
            "location": "/plugins/builtins/#access-settings-and-config", 
            "text": "Will takes care of passing in environment variables and config via the  settings  module.  To use it:  config.py:  HELLO_MESSAGE =  Bonjour from config.py   or, on the shell:  # note the `WILL_` prefix\nexport WILL_HELLO_MESSSAGE= Bonjour from the environment   then, in any plugin:   from will import settings\n\nclass BonjourPlugin(WillPlugin):\n\n    @respond_to( bonjour )\n    def say_bonjour_will(self, message):\n        self.reply(settings.HELLO_MESSAGE)  You can also mark one or more settings as required for your plugin with the  require_settings  decorator, and they'll be checked on startup.  from will import settings\n\nclass BonjourPlugin(WillPlugin):\n\n    @require_settings( HELLO_MESSAGE ,  ANOTHER_SETTING )\n    @respond_to( bonjour )\n    def say_bonjour_will(self, message):\n        self.reply(settings.HELLO_MESSAGE)  When will starts up, he'll make sure they've been set:", 
            "title": "Access settings and config"
        }, 
        {
            "location": "/plugins/builtins/#getting-a-rooms-history", 
            "text": "Sometimes you'll want to retrieve a room's history. No problem - get the room's object, and the last 20 messages are sitting on  analysis.history .  class HistoryPlugin(WillPlugin):\n\n    @respond_to( ^get last message )\n    def get_history(self, message):\n        room = self.get_room_from_message(message)\n        self.reply(room.analysis[ history ][-1])", 
            "title": "Getting a room's history"
        }, 
        {
            "location": "/plugins/builtins/#parse-natural-time", 
            "text": "Often, it's useful to be able to talk to will about time in natural language.  To make that easy, will includes the helper functions built on  parsedatetime  and  natural :  self.parse_natural_time  and  self.to_natural_day_and_time .", 
            "title": "Parse natural time"
        }, 
        {
            "location": "/plugins/builtins/#parse_natural_time", 
            "text": "self.parse_natural_time(time_string)  parses a textual time string, and returns a  datetime  object.  @respond_to( remind me on (?P remind_time .*) )\ndef remind_me_at(self, message, remind_time=None):\n    parsed_time = self.parse_natural_time(remind_time)", 
            "title": "parse_natural_time"
        }, 
        {
            "location": "/plugins/builtins/#to_natural_day_and_time", 
            "text": "self.to_natural_day_and_time(my_datetime)  converts a python  datetime  into a human-friendly string.  @respond_to( show_reminders )\ndef remind_me_at(self, message, remind_time=None):\n    reminders = self.load( reminders )\n    for r in reminders:\n        natural_time = self.to_natural_day_and_time(r)\n        self.say( On %s  % natural_time)  Now you've got the hang of how to write your own plugins - but before you reinvent the wheel, take a look at  what plugins are included in will !", 
            "title": "to_natural_day_and_time"
        }, 
        {
            "location": "/plugins/bundled/", 
            "text": "Included Plugins\n\n\nWill comes with batteries included, and already does a number of useful things - more are welcome via PR!  Note that not all of these commands are listed in \n@will help\n - some are rare enough that they didn't make sense to add.\n\n\nHere's what he does out of the box:\n\n\nAdministration\n\n\nKeepalive\n\n\nThis plugin pings will once a minute at \nPUBLIC_URL\n, making sure his processes aren't idled in installations like heroku.\n\n\nPing\n\n\nHe's a robot. He should respond to ping. :)\n\n\n\n\nSay\n\n\nThis provides a web endpoint at \n/say/some-phrase\n that will will speak into \nDEFAULT_ROOM\n.  Helpful for pay-no-attention-to-the-hand-behind-the-curtain demos.\n\n\n\n\nStorage\n\n\nProvides several \nadmin-only\n commands for manipulating will's underlying storage.  These methods are also case-sensitive, because they can do Bad Things.\n\n\n\n\n@will How big is the db?\n: Lists the db size in human-friendly units.\n\n\n@will SERIOUSLY. Clear ____\n: Clears a key from the storage\n\n\n@will SERIOUSLY. REALLY. Clear all keys.\n: Clears \neverything\n from storage.  Will will definitely not work after this without a restart, and will tell you so.\n\n\n@will Show me the storage for ____\n: Shows the raw storage value for a given key.\n\n\n\n\nChat rooms\n\n\nProvides a couple of methods for listing and updating will's internal chat room knowledge, and manipulating the current room.\n\n\n\n\n@will what are the rooms?\n:  List the rooms he knows about, including their hipchat IDs.\n\n\n@will who is in this room?\n: List all the participants of the room he's in, including their name and mention name. \n\n\n@will update the room list\n:  Get a new list of rooms from the chat server.\n\n\n@will new topic ____\n:   Set the room topic.\n\n\n\n\nDevops\n\n\nWill has served as the devops team at a couple different companies, but we haven't yet been able to get the IP sorted to abstract and open-source those plugins.  So, for the moment, he just includes a couple basics:\n\n\nEmergency Contacts\n\n\nSaves a set of emergency contacts for team members, and provides a way for anyone on the team to get them in, well, emergencies.\n\n\n\n\n@will set my contact info to ____\n: Accepts a multi-line string with whatever contact info you want to provide.\n\n\n@will contact info\n: Lists contact info for all the team members who have provided it.\n\n\n\n\nGithub status\n\n\nGithub is a critical piece of infrastructure for most dev shops.  When it's having troubles, it's good to know.  This plugin checks github's \nstatus api\n, and alerts chat with the problem when they go down, and again when they're back up.\n\n\nHeroku status\n\n\nHeroku is also really widely used, and if you use it, when it's having troubles, it's good to know.  This plugin checks heroku's \nstatus api\n, and alerts chat with the problem when they go down, and again they're back up.\n\n\nNote: if you don't use heroku, remember you can always disable this plugin in \nconfig.py\n:\n\n\nPLUGIN_BLACKLIST = [\n    \nwill.plugins.devops.heroku_is_up\n,\n]\n\n\n\n\nPagerDuty integration\n\n\nIn case if you have a PagerDuty account and the PD alerts are integrated with your HipChat server, you probably want this feature. You can acknowledge/resolve incidents using @will and what's more, you can set up a maintenance window as well!\n\n\nIf you've set both \nPAGERDUTY_SUBDOMAIN\n and \nPAGERDUTY_API_KEY\n and enabled the plugin in \nconfig.py\n - since it's disabled by default - the plugin will work for you. Get one full access api key from https://YOURSUBDOMAIN.pagerduty.com/api_keys.\n\n\nThis plugin assumes that your PagerDuty e-mail address and your HipChat e-mail address are the same, this is how will associates your HipChat account with PagerDuty account.\n\n\nAcknowledge\n\n\nYou can acknowledge the ongoing incidents. You can do 3 things:\n\n\n\n\n@will pd ack\n: Acknowledge all open incidents assigned to you\n\n\n@will pd ack!\n: Acknowledge all open incidents\n\n\n@will pd ack [incident number 1] [incident number 2]\n: Acknowledge one or more specific incidents\n\n\n\n\n\n\nResolve\n\n\nYou can resolve the acknowledged incidents. You can do 3 things:\n\n\n\n\n@will pd resolve\n: Resolve all acknowledged incidents assigned to you\n\n\n@will pd resolve!\n: Resolve all acknowledged incidents\n\n\n@will pd resolve [incident number 1] [incident number 2]\n: Resolve one or more specific incidents\n\n\n\n\n\n\nReassign\n\n\nYou can reassign one or more incidents to somebody else. \n\n\n@will pd reassign [incident number 1] [incident number2] [mention name]\n: reassign one or more specific incidents.\n\n\n\n\nSchedule maintenance window\n\n\nYou can schedule a maintenance window for a specific service. The last - hour - parameter is optional. The default value is \n1 hour\n.\n\n\n@will pd maintenance [service name] [hour(s)]h\n: Schedule a new maintenance window for x hours\n\n\n\n\nFriendly\n\n\nWill has personality, and we love that about him.  The friendly module includes some nice, silly, and appreciative aspects to will that really rounds out his personality.\n\n\nGood morning / Good night\n\n\nWill responds to \"good morning\", and \"good night\" appropriately, if he hears it.  If it's Friday, he'll even tell you to have a good weekend!\n\n\nHello\n\n\nSaying hello is important.\n\n\n\n\nThanks\n\n\nA little politeness goes a long way.\n\n\n\n\nCookies\n\n\nWe promised silly.\n\n\n\n\nThat's what she said.\n\n\nBecause seriously, bro. Read some awesome thought-provoking quotes, instead.\n\n\n\n\nLove\n\n\nOne day, you'll find yourself saying this.  The response will make your week.\n\n\n\n\nFun\n\n\nThere are a number of fun-facing plugins.  Check 'em out in the fun module or let them surprise you.\n\n\n\n\nHelp\n\n\nHelp\n\n\nLists all the plugin commands with docstrings, bundled by module.\n\n\n\n\nProgrammer help\n\n\nList all regexes for registered \n@hear\n and \n@respond_to\n decorators.  This is what help used to be, and may be pulled in the near future.\n\n\n\n\nProductivity\n\n\nBitly\n\n\nIf you want to shorten long URL using Bitly API, Will can do that for you in a few seconds:\n\n\n\n\nHangout\n\n\nIf you've set a \nHANGOUT_URL\n, will will toss it in chat for you:\n\n\n\n\nImage me\n\n\nSometimes, a picture is worth a thousand words.\n\n\n\n\nImage me works out of the box, but may not in future releases (we're using a pretty hacky way to get search results.)  If you rely on it, configure \nimage me\n properly by setting the following two variables in \nconfig.py\n or \nin your environment with the appropriate \nWILL_\n prefix\n. Here are some instructions on where to obtain both.\n\n\n\n\nGOOGLE_API_KEY\n\n\nGo to the \nGoogle Developers Console\n.\n\n\nFrom the menu in the top left, choose \nAPI Manager -\n Credentials\n.\n\n\nClick \nCreate credentials\n from the drop down, then \nAPI Key\n, that's the key you need here.\n\n\nOptionally, give the key a suitable human-readable name so it looks nice in the list e.g. \nwill-api\n.\n\n\nGOOGLE_CUSTOM_SEARCH_ENGINE_ID\n\n\nSetup a custom search engine\n (CSE) if you don't already have one.\n\n\nYou'll need to provide a site for the CSE to search - just input anything, so the wizard can create the CSE.\n\n\nType something useful like \nWill\n in the name field and create the CSE.\n\n\nEdit the settings for the CSE you just created, and in the \nSites to search\n section, change the drop-down to \nSearch the entire web but emphasize included sites\n.\n\n\nDelete the \"anything\" site you added two steps ago, to clean it up.\n\n\nIn the \nDetails\n section, click the \nSearch engine ID\n button, and copy the ID which you need here.\n\n\n\n\nGif me\n\n\nLike image me, but \nalive\n.\n\n\n\n\nRemind me\n\n\nThis saves our bacon every day. Timeboxes meetings, helps people remember appointments, and enforces self-control.\n\n\n\n\nThen, when it's 3pm, and I still haven't stopped coding to eat:\n\n\n\n\nOr, more practically,\n\n\n\n\nRemind somebody\n\n\nYou can also remind others as well.\n\n\n\n\nWorld time\n\n\nWe're a remote company. Maybe you are too. Or your clients are.  Or the light/dark cycle of the world just fascinates you.  If any of these are you, just ask Will to get the time in pretty much any city on earth.  Even our globe-trotting CEO hasn't been able to stump him.\n\n\n\n\nVersion\n\n\nProvides information about the release version of @will.\n\n\n\n\n@will version\n: Show the current running version.\n\n\n\n\nWeb\n\n\nThis module's all about web-facing content.\n\n\nHome page\n\n\nWill also includes a home page, so you can fire him, up, browse to his URL, and see his smiling face.\n\n\n\n\nYou now know everything about plugins.  Maybe you're wondering about the \nfiner points of config\n?  Or perhaps, you're ready to \ndeploy your will\n?", 
            "title": "Bundled Plugins"
        }, 
        {
            "location": "/plugins/bundled/#included-plugins", 
            "text": "Will comes with batteries included, and already does a number of useful things - more are welcome via PR!  Note that not all of these commands are listed in  @will help  - some are rare enough that they didn't make sense to add.  Here's what he does out of the box:", 
            "title": "Included Plugins"
        }, 
        {
            "location": "/plugins/bundled/#administration", 
            "text": "", 
            "title": "Administration"
        }, 
        {
            "location": "/plugins/bundled/#keepalive", 
            "text": "This plugin pings will once a minute at  PUBLIC_URL , making sure his processes aren't idled in installations like heroku.", 
            "title": "Keepalive"
        }, 
        {
            "location": "/plugins/bundled/#ping", 
            "text": "He's a robot. He should respond to ping. :)", 
            "title": "Ping"
        }, 
        {
            "location": "/plugins/bundled/#say", 
            "text": "This provides a web endpoint at  /say/some-phrase  that will will speak into  DEFAULT_ROOM .  Helpful for pay-no-attention-to-the-hand-behind-the-curtain demos.", 
            "title": "Say"
        }, 
        {
            "location": "/plugins/bundled/#storage", 
            "text": "Provides several  admin-only  commands for manipulating will's underlying storage.  These methods are also case-sensitive, because they can do Bad Things.   @will How big is the db? : Lists the db size in human-friendly units.  @will SERIOUSLY. Clear ____ : Clears a key from the storage  @will SERIOUSLY. REALLY. Clear all keys. : Clears  everything  from storage.  Will will definitely not work after this without a restart, and will tell you so.  @will Show me the storage for ____ : Shows the raw storage value for a given key.", 
            "title": "Storage"
        }, 
        {
            "location": "/plugins/bundled/#chat-rooms", 
            "text": "Provides a couple of methods for listing and updating will's internal chat room knowledge, and manipulating the current room.   @will what are the rooms? :  List the rooms he knows about, including their hipchat IDs.  @will who is in this room? : List all the participants of the room he's in, including their name and mention name.   @will update the room list :  Get a new list of rooms from the chat server.  @will new topic ____ :   Set the room topic.", 
            "title": "Chat rooms"
        }, 
        {
            "location": "/plugins/bundled/#devops", 
            "text": "Will has served as the devops team at a couple different companies, but we haven't yet been able to get the IP sorted to abstract and open-source those plugins.  So, for the moment, he just includes a couple basics:", 
            "title": "Devops"
        }, 
        {
            "location": "/plugins/bundled/#emergency-contacts", 
            "text": "Saves a set of emergency contacts for team members, and provides a way for anyone on the team to get them in, well, emergencies.   @will set my contact info to ____ : Accepts a multi-line string with whatever contact info you want to provide.  @will contact info : Lists contact info for all the team members who have provided it.", 
            "title": "Emergency Contacts"
        }, 
        {
            "location": "/plugins/bundled/#github-status", 
            "text": "Github is a critical piece of infrastructure for most dev shops.  When it's having troubles, it's good to know.  This plugin checks github's  status api , and alerts chat with the problem when they go down, and again when they're back up.", 
            "title": "Github status"
        }, 
        {
            "location": "/plugins/bundled/#heroku-status", 
            "text": "Heroku is also really widely used, and if you use it, when it's having troubles, it's good to know.  This plugin checks heroku's  status api , and alerts chat with the problem when they go down, and again they're back up.  Note: if you don't use heroku, remember you can always disable this plugin in  config.py :  PLUGIN_BLACKLIST = [\n     will.plugins.devops.heroku_is_up ,\n]", 
            "title": "Heroku status"
        }, 
        {
            "location": "/plugins/bundled/#pagerduty-integration", 
            "text": "In case if you have a PagerDuty account and the PD alerts are integrated with your HipChat server, you probably want this feature. You can acknowledge/resolve incidents using @will and what's more, you can set up a maintenance window as well!  If you've set both  PAGERDUTY_SUBDOMAIN  and  PAGERDUTY_API_KEY  and enabled the plugin in  config.py  - since it's disabled by default - the plugin will work for you. Get one full access api key from https://YOURSUBDOMAIN.pagerduty.com/api_keys.  This plugin assumes that your PagerDuty e-mail address and your HipChat e-mail address are the same, this is how will associates your HipChat account with PagerDuty account.", 
            "title": "PagerDuty integration"
        }, 
        {
            "location": "/plugins/bundled/#acknowledge", 
            "text": "You can acknowledge the ongoing incidents. You can do 3 things:   @will pd ack : Acknowledge all open incidents assigned to you  @will pd ack! : Acknowledge all open incidents  @will pd ack [incident number 1] [incident number 2] : Acknowledge one or more specific incidents", 
            "title": "Acknowledge"
        }, 
        {
            "location": "/plugins/bundled/#resolve", 
            "text": "You can resolve the acknowledged incidents. You can do 3 things:   @will pd resolve : Resolve all acknowledged incidents assigned to you  @will pd resolve! : Resolve all acknowledged incidents  @will pd resolve [incident number 1] [incident number 2] : Resolve one or more specific incidents", 
            "title": "Resolve"
        }, 
        {
            "location": "/plugins/bundled/#reassign", 
            "text": "You can reassign one or more incidents to somebody else.   @will pd reassign [incident number 1] [incident number2] [mention name] : reassign one or more specific incidents.", 
            "title": "Reassign"
        }, 
        {
            "location": "/plugins/bundled/#schedule-maintenance-window", 
            "text": "You can schedule a maintenance window for a specific service. The last - hour - parameter is optional. The default value is  1 hour .  @will pd maintenance [service name] [hour(s)]h : Schedule a new maintenance window for x hours", 
            "title": "Schedule maintenance window"
        }, 
        {
            "location": "/plugins/bundled/#friendly", 
            "text": "Will has personality, and we love that about him.  The friendly module includes some nice, silly, and appreciative aspects to will that really rounds out his personality.", 
            "title": "Friendly"
        }, 
        {
            "location": "/plugins/bundled/#good-morning-good-night", 
            "text": "Will responds to \"good morning\", and \"good night\" appropriately, if he hears it.  If it's Friday, he'll even tell you to have a good weekend!", 
            "title": "Good morning / Good night"
        }, 
        {
            "location": "/plugins/bundled/#hello", 
            "text": "Saying hello is important.", 
            "title": "Hello"
        }, 
        {
            "location": "/plugins/bundled/#thanks", 
            "text": "A little politeness goes a long way.", 
            "title": "Thanks"
        }, 
        {
            "location": "/plugins/bundled/#cookies", 
            "text": "We promised silly.", 
            "title": "Cookies"
        }, 
        {
            "location": "/plugins/bundled/#thats-what-she-said", 
            "text": "Because seriously, bro. Read some awesome thought-provoking quotes, instead.", 
            "title": "That's what she said."
        }, 
        {
            "location": "/plugins/bundled/#love", 
            "text": "One day, you'll find yourself saying this.  The response will make your week.", 
            "title": "Love"
        }, 
        {
            "location": "/plugins/bundled/#fun", 
            "text": "There are a number of fun-facing plugins.  Check 'em out in the fun module or let them surprise you.", 
            "title": "Fun"
        }, 
        {
            "location": "/plugins/bundled/#help", 
            "text": "", 
            "title": "Help"
        }, 
        {
            "location": "/plugins/bundled/#help_1", 
            "text": "Lists all the plugin commands with docstrings, bundled by module.", 
            "title": "Help"
        }, 
        {
            "location": "/plugins/bundled/#programmer-help", 
            "text": "List all regexes for registered  @hear  and  @respond_to  decorators.  This is what help used to be, and may be pulled in the near future.", 
            "title": "Programmer help"
        }, 
        {
            "location": "/plugins/bundled/#productivity", 
            "text": "", 
            "title": "Productivity"
        }, 
        {
            "location": "/plugins/bundled/#bitly", 
            "text": "If you want to shorten long URL using Bitly API, Will can do that for you in a few seconds:", 
            "title": "Bitly"
        }, 
        {
            "location": "/plugins/bundled/#hangout", 
            "text": "If you've set a  HANGOUT_URL , will will toss it in chat for you:", 
            "title": "Hangout"
        }, 
        {
            "location": "/plugins/bundled/#image-me", 
            "text": "Sometimes, a picture is worth a thousand words.   Image me works out of the box, but may not in future releases (we're using a pretty hacky way to get search results.)  If you rely on it, configure  image me  properly by setting the following two variables in  config.py  or  in your environment with the appropriate  WILL_  prefix . Here are some instructions on where to obtain both.   GOOGLE_API_KEY  Go to the  Google Developers Console .  From the menu in the top left, choose  API Manager -  Credentials .  Click  Create credentials  from the drop down, then  API Key , that's the key you need here.  Optionally, give the key a suitable human-readable name so it looks nice in the list e.g.  will-api .  GOOGLE_CUSTOM_SEARCH_ENGINE_ID  Setup a custom search engine  (CSE) if you don't already have one.  You'll need to provide a site for the CSE to search - just input anything, so the wizard can create the CSE.  Type something useful like  Will  in the name field and create the CSE.  Edit the settings for the CSE you just created, and in the  Sites to search  section, change the drop-down to  Search the entire web but emphasize included sites .  Delete the \"anything\" site you added two steps ago, to clean it up.  In the  Details  section, click the  Search engine ID  button, and copy the ID which you need here.", 
            "title": "Image me"
        }, 
        {
            "location": "/plugins/bundled/#gif-me", 
            "text": "Like image me, but  alive .", 
            "title": "Gif me"
        }, 
        {
            "location": "/plugins/bundled/#remind-me", 
            "text": "This saves our bacon every day. Timeboxes meetings, helps people remember appointments, and enforces self-control.   Then, when it's 3pm, and I still haven't stopped coding to eat:   Or, more practically,", 
            "title": "Remind me"
        }, 
        {
            "location": "/plugins/bundled/#remind-somebody", 
            "text": "You can also remind others as well.", 
            "title": "Remind somebody"
        }, 
        {
            "location": "/plugins/bundled/#world-time", 
            "text": "We're a remote company. Maybe you are too. Or your clients are.  Or the light/dark cycle of the world just fascinates you.  If any of these are you, just ask Will to get the time in pretty much any city on earth.  Even our globe-trotting CEO hasn't been able to stump him.", 
            "title": "World time"
        }, 
        {
            "location": "/plugins/bundled/#version", 
            "text": "Provides information about the release version of @will.   @will version : Show the current running version.", 
            "title": "Version"
        }, 
        {
            "location": "/plugins/bundled/#web", 
            "text": "This module's all about web-facing content.", 
            "title": "Web"
        }, 
        {
            "location": "/plugins/bundled/#home-page", 
            "text": "Will also includes a home page, so you can fire him, up, browse to his URL, and see his smiling face.   You now know everything about plugins.  Maybe you're wondering about the  finer points of config ?  Or perhaps, you're ready to  deploy your will ?", 
            "title": "Home page"
        }, 
        {
            "location": "/config/", 
            "text": "Configuring Will\n\n\nMost of will's configuration is done interactively, using \nrun_will.py\n, or specifying via the plugins.  There are, however a few built-in settings and config worth covering.  We'll aim to address all of them here.\n\n\nEnvironment variables\n\n\nAll environment variables prefixed with \nWILL_\n are imported into will's \nsettings\n modules.\n\n\nIn best practices, you should keep all of the following in environment variables:\n\n\n\n\nWILL_SLACK_API_TOKEN\n\n\nWILL_HIPCHAT_USERNAME\n\n\nWILL_HIPCHAT_PASSWORD\n\n\nWILL_HIPCHAT_V2_TOKEN\n\n\nWILL_HIPCHAT_V1_TOKEN\n\n\nWILL_ROCKETCHAT_USERNAME\n\n\nWILL_ROCKETCHAT_PASSWORD\n\n\nWILL_ROCKETCHAT_URL\n\n\nWILL_REDIS_URL\n\n\nAny other tokens, keys, passwords, or sensitive URLS.\n\n\n\n\nWe've made it easy.  No excuses. :)\n\n\nconfig.py\n\n\nConfig.py is where all of your non-sensitive settings should go.   This includes things like:\n\n\n\n\nPLUGINS\n: The list of plugins to run,\n\n\nPLUGIN_BLACKLIST\n: The list of plugins to ignore, even if they're in \nPLUGINS\n,\n\n\nIO_BACKENDS\n: The list services you want Will to connect to,\n\n\nANALYZE_BACKENDS\n: The list of message-analysis backends you want Will to run through.\n\n\nGENERATION_BACKENDS\n: The list of reply-generation backends you want Will to go through.\n\n\nEXECUTION_BACKENDS\n: The list of decision-making and execution backends you want Will to go through (we recommend just having one.)\n\n\nSTORAGE_BACKEND\n: Which backend you'd like to use for Will to store his long-term memory. (Built-in: 'redis', 'couchbase', 'file')\n\n\nPUBSUB_BACKEND\n: Which backend you'd like to use for Will to use for his working memory. (Built-in: 'redis'.  Soon: 'zeromq', 'builtin')\n\n\nENCYPTION_BACKEND\n: Which backend you'd like to use for Will to encrypt his storage and memory. (Built-in: 'aes'.)\n\n\nPUBLIC_URL\n: The publicly accessible URL will can reach himself at (used for \nkeepalive\n),\n\n\nHTTPSERVER_PORT\n: The port will should handle HTTP requests on.  Defaults to 80, set to \n 1024 if you don't have sudo,\n\n\nREDIS_MAX_CONNECTIONS\n: The maximum number of connections to make to redis, for connection pooling.\n\n\nFUZZY_MINIMUM_MATCH_CONFIDENCE\n:  What percentage of confidence Will should have before replying to a fuzzy match.\n\n\nFUZZY_REGEX_ALLOWABLE_ERRORS\n:  The maximum number of letters that can be wrong in trying to make a fuzzy match.\n\n\nSLACK_DEFAULT_CHANNEL\n: The default Slack channel to send messages to (via webhooks, etc)\n\n\nHIPCHAT_ROOMS\n: The list of rooms to join,\n\n\nHIPCHAT_DEFAULT_ROOM\n: The room to send messages that come from web requests to,\n\n\nDEFAULT_BACKEND\n: The service to send messages that come from web requests to,\n\n\nTEMPLATE_DIRS\n: Extra directories to look for templates,\n\n\nADMINS\n: The mention names of all the admins,\n\n\nLOGLEVEL\n: What logging level to use,\n\n\nHIPCHAT_SERVER\n: if you're using the \nHipChat server beta\n, the hostname of the server,\n\n\nALLOW_INSECURE_HIPCHAT_SERVER\n: the option to disable SSL checks (seriously, don't),\n\n\nENABLE_INTERNAL_ENCRYPTION\n: the option to turn off internal encryption (not recommended, but you can do it.)\n\n\nPROXY_URL\n: Proxy server to use, consider exporting it as \nWILL_PROXY_URL\n environment variable, if it contains sensitive information\n\n\nand all of your non-sensitive plugin settings.\n\n\n\n\nMore expansive documentation on all of those settings is in \nconfig.py\n, right where you need it.\n\n\nHow environment variables and config.py are combined\n\n\nThe environment variables and config.py are combined, and made available to the rest of the app at:\n\n\nfrom will import settings\n\nprint settings.MY_SETTING_NAME\n\n\n\n\nThe rules for combining are fairly straightforward:\n\n\n\n\nAll environment variables that start with \nWILL_\n are imported, and \nWILL_\n is stripped off their name. (i.e. \nWILL_PORT\n becomes \nPORT\n)\n\n\n\n\nAll variables from \nconfig.py\n are imported.  If there is a conflict, \nconfig.py\n wins, and a message is displayed:\n\n\n\n\n\n\n\n\nSome smart defaulting happens inside settings.py for important variables.  For the moment, I'm going to leave that out of the docs, and refer you to \nsettings.py\n as I \nbelieve\n things should Just Work, and most people should never need to care.  If this decision's wrong, please open an issue, and these docs will be improved!\n\n\n\n\n\n\nThat's it for config.  Now, you can either do a deeper dive into \nWill's brain\n, or just get your will \ndeployed\n!", 
            "title": "Configure"
        }, 
        {
            "location": "/config/#configuring-will", 
            "text": "Most of will's configuration is done interactively, using  run_will.py , or specifying via the plugins.  There are, however a few built-in settings and config worth covering.  We'll aim to address all of them here.", 
            "title": "Configuring Will"
        }, 
        {
            "location": "/config/#environment-variables", 
            "text": "All environment variables prefixed with  WILL_  are imported into will's  settings  modules.  In best practices, you should keep all of the following in environment variables:   WILL_SLACK_API_TOKEN  WILL_HIPCHAT_USERNAME  WILL_HIPCHAT_PASSWORD  WILL_HIPCHAT_V2_TOKEN  WILL_HIPCHAT_V1_TOKEN  WILL_ROCKETCHAT_USERNAME  WILL_ROCKETCHAT_PASSWORD  WILL_ROCKETCHAT_URL  WILL_REDIS_URL  Any other tokens, keys, passwords, or sensitive URLS.   We've made it easy.  No excuses. :)", 
            "title": "Environment variables"
        }, 
        {
            "location": "/config/#configpy", 
            "text": "Config.py is where all of your non-sensitive settings should go.   This includes things like:   PLUGINS : The list of plugins to run,  PLUGIN_BLACKLIST : The list of plugins to ignore, even if they're in  PLUGINS ,  IO_BACKENDS : The list services you want Will to connect to,  ANALYZE_BACKENDS : The list of message-analysis backends you want Will to run through.  GENERATION_BACKENDS : The list of reply-generation backends you want Will to go through.  EXECUTION_BACKENDS : The list of decision-making and execution backends you want Will to go through (we recommend just having one.)  STORAGE_BACKEND : Which backend you'd like to use for Will to store his long-term memory. (Built-in: 'redis', 'couchbase', 'file')  PUBSUB_BACKEND : Which backend you'd like to use for Will to use for his working memory. (Built-in: 'redis'.  Soon: 'zeromq', 'builtin')  ENCYPTION_BACKEND : Which backend you'd like to use for Will to encrypt his storage and memory. (Built-in: 'aes'.)  PUBLIC_URL : The publicly accessible URL will can reach himself at (used for  keepalive ),  HTTPSERVER_PORT : The port will should handle HTTP requests on.  Defaults to 80, set to   1024 if you don't have sudo,  REDIS_MAX_CONNECTIONS : The maximum number of connections to make to redis, for connection pooling.  FUZZY_MINIMUM_MATCH_CONFIDENCE :  What percentage of confidence Will should have before replying to a fuzzy match.  FUZZY_REGEX_ALLOWABLE_ERRORS :  The maximum number of letters that can be wrong in trying to make a fuzzy match.  SLACK_DEFAULT_CHANNEL : The default Slack channel to send messages to (via webhooks, etc)  HIPCHAT_ROOMS : The list of rooms to join,  HIPCHAT_DEFAULT_ROOM : The room to send messages that come from web requests to,  DEFAULT_BACKEND : The service to send messages that come from web requests to,  TEMPLATE_DIRS : Extra directories to look for templates,  ADMINS : The mention names of all the admins,  LOGLEVEL : What logging level to use,  HIPCHAT_SERVER : if you're using the  HipChat server beta , the hostname of the server,  ALLOW_INSECURE_HIPCHAT_SERVER : the option to disable SSL checks (seriously, don't),  ENABLE_INTERNAL_ENCRYPTION : the option to turn off internal encryption (not recommended, but you can do it.)  PROXY_URL : Proxy server to use, consider exporting it as  WILL_PROXY_URL  environment variable, if it contains sensitive information  and all of your non-sensitive plugin settings.   More expansive documentation on all of those settings is in  config.py , right where you need it.", 
            "title": "config.py"
        }, 
        {
            "location": "/config/#how-environment-variables-and-configpy-are-combined", 
            "text": "The environment variables and config.py are combined, and made available to the rest of the app at:  from will import settings\n\nprint settings.MY_SETTING_NAME  The rules for combining are fairly straightforward:   All environment variables that start with  WILL_  are imported, and  WILL_  is stripped off their name. (i.e.  WILL_PORT  becomes  PORT )   All variables from  config.py  are imported.  If there is a conflict,  config.py  wins, and a message is displayed:     Some smart defaulting happens inside settings.py for important variables.  For the moment, I'm going to leave that out of the docs, and refer you to  settings.py  as I  believe  things should Just Work, and most people should never need to care.  If this decision's wrong, please open an issue, and these docs will be improved!    That's it for config.  Now, you can either do a deeper dive into  Will's brain , or just get your will  deployed !", 
            "title": "How environment variables and config.py are combined"
        }, 
        {
            "location": "/backends/overall/", 
            "text": "Backend Overview\n\n\nWill is designed rather a lot like our own brains.\n\n\nHis backends are specific parts of the process of noticing something, deciding what to do, and taking action, and they each interact with each other.\n\n\nJust like us, he hears and sees things (\nio\n), understands the context in which they happened (\nanalysis\n), considers possible actions (\ngeneration\n), decides on something to do (\nexecution\n), and does it (\nio\n).  Along the way, he has both short term, working memory that lets these processes talk to each other (\npubsub\n), and long-term, permanent memory (\nstorage\n).\n\n\nIf you've been thinking about diving into Artificial Intelligence or bots, and wondering how it works, the answer lies right there, in your own head.\n\n\nBelow, you can dig a little deeper, see how each piece of Will's brain works, what things you should think about as you set him up, and how you can make him even better.\n\n\n\n\nNoticing and Acting \nio\n\n\nAnalyzing and Context \nanalysis\n\n\nGenerating possible actions \ngeneration\n\n\nDeciding what to do \nexecution\n\n\nShort-term, working memory \npubsub\n\n\nLong term memory \nstorage", 
            "title": "Overview"
        }, 
        {
            "location": "/backends/overall/#backend-overview", 
            "text": "Will is designed rather a lot like our own brains.  His backends are specific parts of the process of noticing something, deciding what to do, and taking action, and they each interact with each other.  Just like us, he hears and sees things ( io ), understands the context in which they happened ( analysis ), considers possible actions ( generation ), decides on something to do ( execution ), and does it ( io ).  Along the way, he has both short term, working memory that lets these processes talk to each other ( pubsub ), and long-term, permanent memory ( storage ).  If you've been thinking about diving into Artificial Intelligence or bots, and wondering how it works, the answer lies right there, in your own head.  Below, you can dig a little deeper, see how each piece of Will's brain works, what things you should think about as you set him up, and how you can make him even better.   Noticing and Acting  io  Analyzing and Context  analysis  Generating possible actions  generation  Deciding what to do  execution  Short-term, working memory  pubsub  Long term memory  storage", 
            "title": "Backend Overview"
        }, 
        {
            "location": "/backends/io/", 
            "text": "IO Backends\n\n\nOverview\n\n\nIO backends are how Will talks and listens to the outside world.  They're designed to abstract away the technical intracies of interfacing with a given platform, and let users just \nuse\n them.\n\n\nWill supports the following io backends:\n\n\n\n\nSlack (\nwill.backends.storage.slack\n)\n\n\nHipchat (\nwill.backends.storage.hipchat\n)\n\n\nRocket.Chat (\nwill.backends.storage.rocketchat\n)\n\n\nShell (\nwill.backends.storage.shell\n)\n\n\n\n\nChoosing your backends\n\n\nThis isn't a zero-sum game with will.  You can use as many backends as you'd like, all at once.\n\n\nSetting your backends\n\n\nTo set your io backends, just update the following in \nconfig.py\n\n\n# Platforms and mediums messages can come in and go out on.\nIO_BACKENDS = [\n    \nwill.backends.io_adapters.slack\n,\n    \nwill.backends.io_adapters.hipchat\n,\n    \nwill.backends.io_adapters.rocketchat\n,\n    \nwill.backends.io_adapters.shell\n,\n]\n\n\n\n\nImplementing a new backend\n\n\nWriting a new storage backend is fairly straightforward - simply subclass \nBaseStorageBackend\n, and implement:\n\n\n\n\nthe five required methods, then\n\n\nspecify any required settings with \nrequired_settings\n.\n\n\n\n\nfrom will.backends.storage.base import BaseStorageBackend\n\n\nclass MyCustomStorageBackend(BaseStorageBackend):\n    \nA custom storage backend using the latest, greatest technology.\n\n    You'll need to provide a GREAT_API_KEY to use it.\n\n    \n\n\n    required_settings = [\n        {\n            \nname\n: \nGREAT_API_KEY\n,\n            \nobtain_at\n: \n1. Go to greatamazingtechnology.com/api\n2. Click \nGenerate API Key\n\n3. Copy that key, and set it in your Will.\n\n,\n        },\n    ]\n\n\n    # All storage backends must supply the following methods:    \n    def __init__(self, *args, **kwargs):\n        # Connects to the storage provider.\n\n    def do_save(self, key, value, expire=None):\n        raise NotImplemented\n\n    def do_load(self, key):\n        raise NotImplemented\n\n    def clear(self, key):\n        raise NotImplemented\n\n    def clear_all_keys(self):\n        raise NotImplemented\n\n\n\n\n\nFrom there, just test it out, and when you're ready, submit a \npull request!\n\n\nNow that you've got hearing and talking sorted, let's look at how \nWill adds context\n.", 
            "title": "Noticing and Talking"
        }, 
        {
            "location": "/backends/io/#io-backends", 
            "text": "", 
            "title": "IO Backends"
        }, 
        {
            "location": "/backends/io/#overview", 
            "text": "IO backends are how Will talks and listens to the outside world.  They're designed to abstract away the technical intracies of interfacing with a given platform, and let users just  use  them.  Will supports the following io backends:   Slack ( will.backends.storage.slack )  Hipchat ( will.backends.storage.hipchat )  Rocket.Chat ( will.backends.storage.rocketchat )  Shell ( will.backends.storage.shell )", 
            "title": "Overview"
        }, 
        {
            "location": "/backends/io/#choosing-your-backends", 
            "text": "This isn't a zero-sum game with will.  You can use as many backends as you'd like, all at once.", 
            "title": "Choosing your backends"
        }, 
        {
            "location": "/backends/io/#setting-your-backends", 
            "text": "To set your io backends, just update the following in  config.py  # Platforms and mediums messages can come in and go out on.\nIO_BACKENDS = [\n     will.backends.io_adapters.slack ,\n     will.backends.io_adapters.hipchat ,\n     will.backends.io_adapters.rocketchat ,\n     will.backends.io_adapters.shell ,\n]", 
            "title": "Setting your backends"
        }, 
        {
            "location": "/backends/io/#implementing-a-new-backend", 
            "text": "Writing a new storage backend is fairly straightforward - simply subclass  BaseStorageBackend , and implement:   the five required methods, then  specify any required settings with  required_settings .   from will.backends.storage.base import BaseStorageBackend\n\n\nclass MyCustomStorageBackend(BaseStorageBackend):\n     A custom storage backend using the latest, greatest technology.\n\n    You'll need to provide a GREAT_API_KEY to use it.\n\n     \n\n    required_settings = [\n        {\n             name :  GREAT_API_KEY ,\n             obtain_at :  1. Go to greatamazingtechnology.com/api\n2. Click  Generate API Key \n3. Copy that key, and set it in your Will. ,\n        },\n    ]\n\n\n    # All storage backends must supply the following methods:    \n    def __init__(self, *args, **kwargs):\n        # Connects to the storage provider.\n\n    def do_save(self, key, value, expire=None):\n        raise NotImplemented\n\n    def do_load(self, key):\n        raise NotImplemented\n\n    def clear(self, key):\n        raise NotImplemented\n\n    def clear_all_keys(self):\n        raise NotImplemented  From there, just test it out, and when you're ready, submit a  pull request!  Now that you've got hearing and talking sorted, let's look at how  Will adds context .", 
            "title": "Implementing a new backend"
        }, 
        {
            "location": "/backends/analysis/", 
            "text": "Overview\n\n\nWe never communicate in the void - there's always a context, and things to read into a particular message, depending who said it, when, and how - and that's exactly what Will's analysis backends are for.  \n\n\nThey look at an incoming message and everything around it, and add context.\n\n\nWill has the following analysis backends built-in, more are on the way (like sentiment analysis) and it's easy to make your own or contribute one to the project:\n\n\n\n\nHistory (\nwill.backends.analysis.history\n)\n\n\nNothing (\nwill.backends.analysis.nothing\n)\n\n\n\n\nChoosing your backends\n\n\nHere's a bit more about the built-ins, and when they'd be a good fit:\n\n\nHistory (\nwill.backends.analysis.history\n)\n\n\nJust adds the last 20 messages he heard into the context, and stores this one for the future. \n\n\nRequired settings\n: None\n\n\nNothing (\nwill.backends.analysis.nothing\n)\n\n\nDoes absolutely nothing.  But it is a nice template for building your own!\n\n\nRequired settings\n: None\n\n\nFor the moment, there's no reason not to just include both built-in backends.  But as Will grows and additional options are added, these documents will be updated to explain the tradeoffs in enabling or disabling certain backends.\n\n\nSetting your backends\n\n\nTo set your analysis backends, just update the following in \nconfig.py\n\n\n# Backends to analyze messages and generate useful metadata\nANALYZE_BACKENDS = [\n    \nwill.backends.analysis.nothing\n,\n    \nwill.backends.analysis.history\n,\n]\n\n\n\n\nContributing a new backend\n\n\nWriting a new analysis backend is fairly straightforward - simply subclass \nBaseStorageBackend\n, and implement the do_analysis method:\n\n\nfrom will.backends.analysis.base import AnalysisBackend\n\nclass NewBackend(AnalysisBackend):\n\n    def do_analyze(self, message):\n        # Do smart stuff\n        return {\n            \nsmart\n: \nstuff\n,\n            \ncool\n: \nthings\n,\n        }\n\n\n\n\n\nFrom there, just test it out, and when you're ready, submit a \npull request!\n\n\nNow we've got context, let's look at how \nWill generates possibilities\n.", 
            "title": "Analysis and Context"
        }, 
        {
            "location": "/backends/analysis/#overview", 
            "text": "We never communicate in the void - there's always a context, and things to read into a particular message, depending who said it, when, and how - and that's exactly what Will's analysis backends are for.    They look at an incoming message and everything around it, and add context.  Will has the following analysis backends built-in, more are on the way (like sentiment analysis) and it's easy to make your own or contribute one to the project:   History ( will.backends.analysis.history )  Nothing ( will.backends.analysis.nothing )", 
            "title": "Overview"
        }, 
        {
            "location": "/backends/analysis/#choosing-your-backends", 
            "text": "Here's a bit more about the built-ins, and when they'd be a good fit:", 
            "title": "Choosing your backends"
        }, 
        {
            "location": "/backends/analysis/#history-willbackendsanalysishistory", 
            "text": "Just adds the last 20 messages he heard into the context, and stores this one for the future.   Required settings : None", 
            "title": "History (will.backends.analysis.history)"
        }, 
        {
            "location": "/backends/analysis/#nothing-willbackendsanalysisnothing", 
            "text": "Does absolutely nothing.  But it is a nice template for building your own!  Required settings : None  For the moment, there's no reason not to just include both built-in backends.  But as Will grows and additional options are added, these documents will be updated to explain the tradeoffs in enabling or disabling certain backends.", 
            "title": "Nothing (will.backends.analysis.nothing)"
        }, 
        {
            "location": "/backends/analysis/#setting-your-backends", 
            "text": "To set your analysis backends, just update the following in  config.py  # Backends to analyze messages and generate useful metadata\nANALYZE_BACKENDS = [\n     will.backends.analysis.nothing ,\n     will.backends.analysis.history ,\n]", 
            "title": "Setting your backends"
        }, 
        {
            "location": "/backends/analysis/#contributing-a-new-backend", 
            "text": "Writing a new analysis backend is fairly straightforward - simply subclass  BaseStorageBackend , and implement the do_analysis method:  from will.backends.analysis.base import AnalysisBackend\n\nclass NewBackend(AnalysisBackend):\n\n    def do_analyze(self, message):\n        # Do smart stuff\n        return {\n             smart :  stuff ,\n             cool :  things ,\n        }  From there, just test it out, and when you're ready, submit a  pull request!  Now we've got context, let's look at how  Will generates possibilities .", 
            "title": "Contributing a new backend"
        }, 
        {
            "location": "/backends/generation/", 
            "text": "Generation Backends\n\n\nOverview\n\n\nGeneration backends are Will's equivalent of that momement when we pause, and run through all the possible things we could say.  Some of them are great ideas.  Some of them are terrible ideas.  But the process of \ngeneration\n doesn't care - it's just about making as many ideas as possible.\n\n\nWill's generation backends do the same thing - try to come up with things Will \ncould\n say or do to respond to what he heard.\n\n\nWill has the following generation backends built-in, and it's easy to add your own or contribute one to the project:\n\n\n\n\nFuzzy Match (all) (\nwill.backends.generation.fuzzy_all_matches\n)\n\n\nFuzzy Match (best) (\nwill.backends.generation.fuzzy_best_match\n)\n\n\nStrict Regex (\nwill.backends.generation.strict_regex\n)\n\n\n\n\nChoosing your backends\n\n\nLike our brain processes, we can have lots of different ways to generate ideas, working together.  You don't have to pick just one generation backend for Will.  Depending on your setup, it might be the more, the merrier.\n\n\nHere's a bit more about the built-ins, and when they'd be a good fit:\n\n\nFuzzy Match (all) (\nwill.backends.generation.fuzzy_all_matches\n)\n\n\nThis uses the fantastic \nfuzzywuzzy\n library to match strings with some fuzziness, as specified by \nFUZZY_MINIMUM_MATCH_CONFIDENCE\n (defaults to 90% confidence) and \nFUZZY_REGEX_ALLOWABLE_ERRORS\n (defaults to 3).\n\n\nGreat if you'd like your Will to be a little flexible, sometimes get things wrong, but to handle typos.\n\n\nRequired settings\n: \nFUZZY_MINIMUM_MATCH_CONFIDENCE\n and \nFUZZY_REGEX_ALLOWABLE_ERRORS\n\n\nFuzzy Match (best) (\nwill.backends.generation.fuzzy_best_match\n)\n\n\nThis backend is very similar to \nfuzzy_all_matches\n, but instead of returning all matches above a certain confidence, it just returns the best one, regardless of how good it is.\n\n\nIn general, there's no reason to use this over \nfuzzy_all_matches\n, unless you have a specific scenario that means you always want a response, but can't be sure of a confidence level.\n\n\nStrict Regex (\nwill.backends.generation.strict_regex\n)\n\n\nGreat for exact matches only.  If you only want your Will to do thing when it hears an exact command, or you have a bunch of different commands you're worried about getting mixed up in the fuzziness, \nstrict_regex\n is the way for you to go.\n\n\nThis is the same behavior that was in Will 1.x and 0.x.\n\n\nSetting your backends\n\n\nTo set your generation backends, just update the following in \nconfig.py\n\n\n# Backends to generate possible actions, and metadata about them.\nGENERATION_BACKENDS = [\n    \nwill.backends.generation.fuzzy_all_matches\n,\n    \nwill.backends.generation.strict_regex\n,\n    # \nwill.backends.generation.fuzzy_best_match\n,\n]\n\n\n\n\nContributing a new backend\n\n\nWriting a new generation backend is easy - just subclass \nGenerationBackend\n, and implement \ndo_generate\n:\n\n\nNote that the method should return a list of \nGeneratedOption\ns, including context, the backend name, and a score.\n\n\nfrom will.backends.generation.base import GenerationBackend, GeneratedOption\n\n\nclass MyGreatGenerationBackend(GenerationBackend):\n\n    def do_generate(self, event):\n        \nReturns a list of GeneratedOptions\n\n        matches = []\n\n        message = event.data\n        for name, l in self.bot.message_listeners.items():\n            if this_is_a_perfect_match(message, l):\n                o = GeneratedOption(context=context, backend=\nregex\n, score=100)\n                matches.append(o)\n\n        return matches\n\n\n\n\n\nFrom there, just test it out, and when you're ready, submit a \npull request!\n\n\nNow we've got a host of possible things Will can do and say.  It's time to look at how \nWill decides what to do\n.", 
            "title": "Generation"
        }, 
        {
            "location": "/backends/generation/#generation-backends", 
            "text": "", 
            "title": "Generation Backends"
        }, 
        {
            "location": "/backends/generation/#overview", 
            "text": "Generation backends are Will's equivalent of that momement when we pause, and run through all the possible things we could say.  Some of them are great ideas.  Some of them are terrible ideas.  But the process of  generation  doesn't care - it's just about making as many ideas as possible.  Will's generation backends do the same thing - try to come up with things Will  could  say or do to respond to what he heard.  Will has the following generation backends built-in, and it's easy to add your own or contribute one to the project:   Fuzzy Match (all) ( will.backends.generation.fuzzy_all_matches )  Fuzzy Match (best) ( will.backends.generation.fuzzy_best_match )  Strict Regex ( will.backends.generation.strict_regex )", 
            "title": "Overview"
        }, 
        {
            "location": "/backends/generation/#choosing-your-backends", 
            "text": "Like our brain processes, we can have lots of different ways to generate ideas, working together.  You don't have to pick just one generation backend for Will.  Depending on your setup, it might be the more, the merrier.  Here's a bit more about the built-ins, and when they'd be a good fit:", 
            "title": "Choosing your backends"
        }, 
        {
            "location": "/backends/generation/#fuzzy-match-all-willbackendsgenerationfuzzy_all_matches", 
            "text": "This uses the fantastic  fuzzywuzzy  library to match strings with some fuzziness, as specified by  FUZZY_MINIMUM_MATCH_CONFIDENCE  (defaults to 90% confidence) and  FUZZY_REGEX_ALLOWABLE_ERRORS  (defaults to 3).  Great if you'd like your Will to be a little flexible, sometimes get things wrong, but to handle typos.  Required settings :  FUZZY_MINIMUM_MATCH_CONFIDENCE  and  FUZZY_REGEX_ALLOWABLE_ERRORS", 
            "title": "Fuzzy Match (all) (will.backends.generation.fuzzy_all_matches)"
        }, 
        {
            "location": "/backends/generation/#fuzzy-match-best-willbackendsgenerationfuzzy_best_match", 
            "text": "This backend is very similar to  fuzzy_all_matches , but instead of returning all matches above a certain confidence, it just returns the best one, regardless of how good it is.  In general, there's no reason to use this over  fuzzy_all_matches , unless you have a specific scenario that means you always want a response, but can't be sure of a confidence level.", 
            "title": "Fuzzy Match (best) (will.backends.generation.fuzzy_best_match)"
        }, 
        {
            "location": "/backends/generation/#strict-regex-willbackendsgenerationstrict_regex", 
            "text": "Great for exact matches only.  If you only want your Will to do thing when it hears an exact command, or you have a bunch of different commands you're worried about getting mixed up in the fuzziness,  strict_regex  is the way for you to go.  This is the same behavior that was in Will 1.x and 0.x.", 
            "title": "Strict Regex (will.backends.generation.strict_regex)"
        }, 
        {
            "location": "/backends/generation/#setting-your-backends", 
            "text": "To set your generation backends, just update the following in  config.py  # Backends to generate possible actions, and metadata about them.\nGENERATION_BACKENDS = [\n     will.backends.generation.fuzzy_all_matches ,\n     will.backends.generation.strict_regex ,\n    #  will.backends.generation.fuzzy_best_match ,\n]", 
            "title": "Setting your backends"
        }, 
        {
            "location": "/backends/generation/#contributing-a-new-backend", 
            "text": "Writing a new generation backend is easy - just subclass  GenerationBackend , and implement  do_generate :  Note that the method should return a list of  GeneratedOption s, including context, the backend name, and a score.  from will.backends.generation.base import GenerationBackend, GeneratedOption\n\n\nclass MyGreatGenerationBackend(GenerationBackend):\n\n    def do_generate(self, event):\n         Returns a list of GeneratedOptions \n        matches = []\n\n        message = event.data\n        for name, l in self.bot.message_listeners.items():\n            if this_is_a_perfect_match(message, l):\n                o = GeneratedOption(context=context, backend= regex , score=100)\n                matches.append(o)\n\n        return matches  From there, just test it out, and when you're ready, submit a  pull request!  Now we've got a host of possible things Will can do and say.  It's time to look at how  Will decides what to do .", 
            "title": "Contributing a new backend"
        }, 
        {
            "location": "/backends/execution/", 
            "text": "Execution Backends\n\n\nOverview\n\n\nAfter we've thought of all the possibilities, we then have to decide what we want to do or say.  That's where Will's execution backends come in.\n\n\nThey take the context created by \nanalysis\n, and the options created by \ngeneration\n, and make a decision on what to do.\n\n\nWill has the following execution backends built-in, and it's easy to make your own or contribute one to the project:\n\n\n\n\nAll (\nwill.backends.execution.all\n)\n\n\nBest Score (\nwill.backends.execution.best_score\n)\n\n\n\n\nChoosing your backends\n\n\nHere's a bit more about the built-ins, and when they'd be a good fit:\n\n\nBest Score (\nwill.backends.execution.best_score\n)\n\n\nThis is the right fit for most people, and it's the most similar to how our brains work.  Will looks at the options he has, and picks the single one he thinks is the best.\n\n\nAll (\nwill.backends.execution.all\n)\n\n\n\n\nThis is Will's crazy, do-everything mode.  He'll take every idea he got in the generation cycle and do \nall\n of them.  Why?  Because he's crazy like that.\n\n\nOr, more likely, because you've built a custom generation backend that limits him down to a set of options you always want done.\n\n\nSetting your backends\n\n\nTo set your execution backends, just update the following in \nconfig.py\n\n\n# The \ndecision making\n backends that look among the generated choices,\n# and decide which to follow. Backends are executed in order, and any\n# backend can stop further evaluation.\nEXECUTION_BACKENDS = [\n    \nwill.backends.execution.best_score\n,\n    # \nwill.backends.execution.all\n,\n]\n\n\n\n\nContributing a new backend\n\n\nWriting a new execution backend is reasonably straightforward - simply subclass \nExecutionBackend\n, and implement \nhandle_execution\n, making sure to call \nself.execute(option)\n for the option(s) you choose.:\n\n\nfrom will.backends.execution.base import ExecutionBackend\n\n\nclass MyRandomExecutionBackend(ExecutionBackend):\n\n    def handle_execution(self, message):\n        random_option = random.choice(message.generation_options)\n        self.execute(random_option)\n\n\n\n\n\nFrom there, just test it out, and when you're ready, submit a \npull request!\n\n\nThat's it for Will's decision making.  If you'd like a little more esoteric deep-dive, let's look at how his \nshort-term memory (pubsub)\n.", 
            "title": "Decisions and Execution"
        }, 
        {
            "location": "/backends/execution/#execution-backends", 
            "text": "", 
            "title": "Execution Backends"
        }, 
        {
            "location": "/backends/execution/#overview", 
            "text": "After we've thought of all the possibilities, we then have to decide what we want to do or say.  That's where Will's execution backends come in.  They take the context created by  analysis , and the options created by  generation , and make a decision on what to do.  Will has the following execution backends built-in, and it's easy to make your own or contribute one to the project:   All ( will.backends.execution.all )  Best Score ( will.backends.execution.best_score )", 
            "title": "Overview"
        }, 
        {
            "location": "/backends/execution/#choosing-your-backends", 
            "text": "Here's a bit more about the built-ins, and when they'd be a good fit:", 
            "title": "Choosing your backends"
        }, 
        {
            "location": "/backends/execution/#best-score-willbackendsexecutionbest_score", 
            "text": "This is the right fit for most people, and it's the most similar to how our brains work.  Will looks at the options he has, and picks the single one he thinks is the best.", 
            "title": "Best Score (will.backends.execution.best_score)"
        }, 
        {
            "location": "/backends/execution/#all-willbackendsexecutionall", 
            "text": "This is Will's crazy, do-everything mode.  He'll take every idea he got in the generation cycle and do  all  of them.  Why?  Because he's crazy like that.  Or, more likely, because you've built a custom generation backend that limits him down to a set of options you always want done.", 
            "title": "All (will.backends.execution.all)"
        }, 
        {
            "location": "/backends/execution/#setting-your-backends", 
            "text": "To set your execution backends, just update the following in  config.py  # The  decision making  backends that look among the generated choices,\n# and decide which to follow. Backends are executed in order, and any\n# backend can stop further evaluation.\nEXECUTION_BACKENDS = [\n     will.backends.execution.best_score ,\n    #  will.backends.execution.all ,\n]", 
            "title": "Setting your backends"
        }, 
        {
            "location": "/backends/execution/#contributing-a-new-backend", 
            "text": "Writing a new execution backend is reasonably straightforward - simply subclass  ExecutionBackend , and implement  handle_execution , making sure to call  self.execute(option)  for the option(s) you choose.:  from will.backends.execution.base import ExecutionBackend\n\n\nclass MyRandomExecutionBackend(ExecutionBackend):\n\n    def handle_execution(self, message):\n        random_option = random.choice(message.generation_options)\n        self.execute(random_option)  From there, just test it out, and when you're ready, submit a  pull request!  That's it for Will's decision making.  If you'd like a little more esoteric deep-dive, let's look at how his  short-term memory (pubsub) .", 
            "title": "Contributing a new backend"
        }, 
        {
            "location": "/backends/pubsub/", 
            "text": "Publish-Subscribe (Pubsub) Backends\n\n\nOverview\n\n\nPubsub backends handle all the internal messaging between Will's core components.  They're designed to be lightweight, reliable, and ephemeral - a lot like our brain's working memory.\n\n\nWill supports the following options for pubsub backend:\n\n\n\n\nRedis (\nwill.backends.pubsub.redis\n)\n\n\n\n\nChoosing a backend\n\n\nRight now, you're stuck with Redis. :)\n\n\nSetting your backends\n\n\nTo set your pubsub backend, just update the following in \nconfig.py\n\n\nPUBSUB_BACKEND = \nredis\n  # \nredis\n, or \nzeromq\n (beta).\n\n\n\n\nContributing a new backend\n\n\nWriting a new pubsub backend is fairly straightforward - simply subclass \nBasePubSub\n, and implement:\n\n\n\n\nthe four required methods, and\n\n\na bootstrap method.\n\n\n\n\nfrom will.backends.pubsub.base import BasePubSub\n\n\nclass MyCustomPubsubBackend(BasePubSub):\n    \nA custom pubsub backend using the latest, greatest framework.\n\n    You'll need to provide a GREAT_API_KEY to use it.\n\n    \n\n    required_settings = [\n        {\n            \nname\n: \nGREAT_API_KEY\n,\n            \nobtain_at\n: \n1. Go to greatamazingframework.com/api\n2. Click \nGenerate API Key\n\n3. Copy that key, and set it in your Will.\n\n,\n        },\n    ]\n\n    def __init__(self, settings):\n        # Do whatever I need to do to kick off the backend.\n\n    def do_subscribe(self, topic):\n        \n\n        Registers with the backend to only get messages matching a specific topic.\n        Where possible, wildcards are allowed\n        \n\n        raise NotImplementedError\n\n    def do_unsubscribe(self, topic):\n        \nUnregisters with the backend for a given topic.\n\n        raise NotImplementedError\n\n    def publish_to_backend(self, topic, str):\n        \nPublishes a string to the backend with a given topic.\n\n        raise NotImplementedError\n\n    def get_from_backend(self):\n        \n\n        Gets the latest pending message from the backend (FIFO).\n        Returns None if no messages are pending, and is expected *not* to be blocking.\n        \n\n        raise NotImplementedError\n\ndef bootstrap(settings)\n    MyCustomPubsubBackend(settings)\n\n\n\n\n\nFrom there, just test it out, and submit a \npull request!\n\n\nThat's it for Will's pubsub backends.  He can also remember things long-term.  For that, read up on his \nlong-term memory (storage)\n.", 
            "title": "Pubsub and short-term memory"
        }, 
        {
            "location": "/backends/pubsub/#publish-subscribe-pubsub-backends", 
            "text": "", 
            "title": "Publish-Subscribe (Pubsub) Backends"
        }, 
        {
            "location": "/backends/pubsub/#overview", 
            "text": "Pubsub backends handle all the internal messaging between Will's core components.  They're designed to be lightweight, reliable, and ephemeral - a lot like our brain's working memory.  Will supports the following options for pubsub backend:   Redis ( will.backends.pubsub.redis )", 
            "title": "Overview"
        }, 
        {
            "location": "/backends/pubsub/#choosing-a-backend", 
            "text": "Right now, you're stuck with Redis. :)", 
            "title": "Choosing a backend"
        }, 
        {
            "location": "/backends/pubsub/#setting-your-backends", 
            "text": "To set your pubsub backend, just update the following in  config.py  PUBSUB_BACKEND =  redis   #  redis , or  zeromq  (beta).", 
            "title": "Setting your backends"
        }, 
        {
            "location": "/backends/pubsub/#contributing-a-new-backend", 
            "text": "Writing a new pubsub backend is fairly straightforward - simply subclass  BasePubSub , and implement:   the four required methods, and  a bootstrap method.   from will.backends.pubsub.base import BasePubSub\n\n\nclass MyCustomPubsubBackend(BasePubSub):\n     A custom pubsub backend using the latest, greatest framework.\n\n    You'll need to provide a GREAT_API_KEY to use it.\n\n     \n    required_settings = [\n        {\n             name :  GREAT_API_KEY ,\n             obtain_at :  1. Go to greatamazingframework.com/api\n2. Click  Generate API Key \n3. Copy that key, and set it in your Will. ,\n        },\n    ]\n\n    def __init__(self, settings):\n        # Do whatever I need to do to kick off the backend.\n\n    def do_subscribe(self, topic):\n         \n        Registers with the backend to only get messages matching a specific topic.\n        Where possible, wildcards are allowed\n         \n        raise NotImplementedError\n\n    def do_unsubscribe(self, topic):\n         Unregisters with the backend for a given topic. \n        raise NotImplementedError\n\n    def publish_to_backend(self, topic, str):\n         Publishes a string to the backend with a given topic. \n        raise NotImplementedError\n\n    def get_from_backend(self):\n         \n        Gets the latest pending message from the backend (FIFO).\n        Returns None if no messages are pending, and is expected *not* to be blocking.\n         \n        raise NotImplementedError\n\ndef bootstrap(settings)\n    MyCustomPubsubBackend(settings)  From there, just test it out, and submit a  pull request!  That's it for Will's pubsub backends.  He can also remember things long-term.  For that, read up on his  long-term memory (storage) .", 
            "title": "Contributing a new backend"
        }, 
        {
            "location": "/backends/storage/", 
            "text": "Storage Backends\n\n\nOverview\n\n\nStorage backends handle all of Will's long-term memory.  They're designed to be durable, reliable, and robust - a lot like our brain's long-term memory, but without the forgetfulness.\n\n\nWill supports the following options for storage backend:\n\n\n\n\nRedis (\nwill.backends.storage.redis\n)\n\n\nCouchbase (\nwill.backends.storage.couchbase\n)\n\n\nFile (\nwill.backends.storage.file\n)\n\n\n\n\nChoosing a backend\n\n\nIn general, we recommend using Redis, especially since for v2.0, it's also required for pubsub to get Will working.  However, in the future, we'll have more pubsub options, and this will be a more option choice.\n\n\nIf you're running in an environment with no access to external resources or ability to install packages, the \nFile\n backend will get you sorted.  If you're already running Couchbase for various reasons, it might make the most sense to use it.\n\n\nBut for the moment, for most configurations, we recommend Redis.  It's stable, fast, well-supported, and just works.\n\n\nSetting your backends\n\n\nTo set your storage backend, just update the following in \nconfig.py\n\n\nSTORAGE_BACKEND = \nredis\n  # \nredis\n, \ncouchbase\n, or \nfile\n.\n\n\n\n\nContributing a new backend\n\n\nWriting a new storage backend is fairly straightforward - simply subclass \nBaseStorageBackend\n, and implement:\n\n\n1) the five required methods, then\n2) specify any required settings with \nrequired_settings\n.\n\n\nfrom will.backends.storage.base import BaseStorageBackend\n\n\nclass MyCustomStorageBackend(BaseStorageBackend):\n    \nA custom storage backend using the latest, greatest technology.\n\n    You'll need to provide a GREAT_API_KEY to use it.\n\n    \n\n\n    required_settings = [\n        {\n            \nname\n: \nGREAT_API_KEY\n,\n            \nobtain_at\n: \n1. Go to greatamazingtechnology.com/api\n2. Click \nGenerate API Key\n\n3. Copy that key, and set it in your Will.\n\n,\n        },\n    ]\n\n\n    # All storage backends must supply the following methods:    \n    def __init__(self, *args, **kwargs):\n        # Connects to the storage provider.\n\n    def do_save(self, key, value, expire=None):\n        raise NotImplemented\n\n    def do_load(self, key):\n        raise NotImplemented\n\n    def clear(self, key):\n        raise NotImplemented\n\n    def clear_all_keys(self):\n        raise NotImplemented\n\n\n\n\n\nFrom there, just test it out, and when you're ready, submit a \npull request!\n\n\nThat's all you need to know to tweak and improve Will's memory.  There's just one topic left in his brain - keeping things private with \nencryption\n.", 
            "title": "Storage and long-term memory"
        }, 
        {
            "location": "/backends/storage/#storage-backends", 
            "text": "", 
            "title": "Storage Backends"
        }, 
        {
            "location": "/backends/storage/#overview", 
            "text": "Storage backends handle all of Will's long-term memory.  They're designed to be durable, reliable, and robust - a lot like our brain's long-term memory, but without the forgetfulness.  Will supports the following options for storage backend:   Redis ( will.backends.storage.redis )  Couchbase ( will.backends.storage.couchbase )  File ( will.backends.storage.file )", 
            "title": "Overview"
        }, 
        {
            "location": "/backends/storage/#choosing-a-backend", 
            "text": "In general, we recommend using Redis, especially since for v2.0, it's also required for pubsub to get Will working.  However, in the future, we'll have more pubsub options, and this will be a more option choice.  If you're running in an environment with no access to external resources or ability to install packages, the  File  backend will get you sorted.  If you're already running Couchbase for various reasons, it might make the most sense to use it.  But for the moment, for most configurations, we recommend Redis.  It's stable, fast, well-supported, and just works.", 
            "title": "Choosing a backend"
        }, 
        {
            "location": "/backends/storage/#setting-your-backends", 
            "text": "To set your storage backend, just update the following in  config.py  STORAGE_BACKEND =  redis   #  redis ,  couchbase , or  file .", 
            "title": "Setting your backends"
        }, 
        {
            "location": "/backends/storage/#contributing-a-new-backend", 
            "text": "Writing a new storage backend is fairly straightforward - simply subclass  BaseStorageBackend , and implement:  1) the five required methods, then\n2) specify any required settings with  required_settings .  from will.backends.storage.base import BaseStorageBackend\n\n\nclass MyCustomStorageBackend(BaseStorageBackend):\n     A custom storage backend using the latest, greatest technology.\n\n    You'll need to provide a GREAT_API_KEY to use it.\n\n     \n\n    required_settings = [\n        {\n             name :  GREAT_API_KEY ,\n             obtain_at :  1. Go to greatamazingtechnology.com/api\n2. Click  Generate API Key \n3. Copy that key, and set it in your Will. ,\n        },\n    ]\n\n\n    # All storage backends must supply the following methods:    \n    def __init__(self, *args, **kwargs):\n        # Connects to the storage provider.\n\n    def do_save(self, key, value, expire=None):\n        raise NotImplemented\n\n    def do_load(self, key):\n        raise NotImplemented\n\n    def clear(self, key):\n        raise NotImplemented\n\n    def clear_all_keys(self):\n        raise NotImplemented  From there, just test it out, and when you're ready, submit a  pull request!  That's all you need to know to tweak and improve Will's memory.  There's just one topic left in his brain - keeping things private with  encryption .", 
            "title": "Contributing a new backend"
        }, 
        {
            "location": "/backends/encryption/", 
            "text": "Encryption Backends\n\n\nOverview\n\n\nEncryption backends are what lets Will keep his thoughts private - safe from prying eyes, and would-be spies.\n\n\nAll of Will's short and long-term memory (\npubsub\n and \nstorage\n) are encrypted by default.\n\n\nWill supports the following options for storage backend, and improvements and more backends are welcome:\n\n\n\n\nAES (\nwill.backends.storage.aes\n) - uses AES in CBC mode to encrypt.\n\n\n\n\nChoosing a backend\n\n\nRight now, your only option is AES.  So go with that! :)\n\n\nSetting your backend\n\n\nTo set your backend, in \nconfig.py\n, set:\n\n\n# Turn on/off encryption in pub/sub and storage (default is on).\n# Causes a small speed bump, but secures messages in an untrusted environment.\n# ENABLE_INTERNAL_ENCRYPTION = True\nENCRYPTION_BACKEND = \naes\n\n\n\n\n\nContributing a new backend\n\n\nWriting a new encryption backend is easy (if you've got the encryption stuff sorted.) Just subclass \nBaseStorageBackend\n, and implement:\n\n\n\n\nencrypt_to_b64\n - a method that take an arbitary python object, and returns an encrypted, base64 string.\n\n\ndecrypt_from_b64\n - a method that takes that base64 string, and returns a python object.\n\n\nProvide a \nbootstrap()\n method that returns an instantiated EncryptionClass.\n\n\n\n\nHere's an example: \n\n\nfrom will.backends.storage.base import BaseStorageBackend\n\n\nclass MyGreatEncryption(WillBaseEncryptionBackend):\n\n    @classmethod\n    def encrypt_to_b64(cls, raw):\n        return binascii.b2a_base64(my_encryption_method(pickle.dumps(raw, -1)))\n\n    @classmethod\n    def decrypt_from_b64(cls, raw_enc):\n        return pickle_loads(binascii.a2b_base64(my_decryption_method(raw_enc)))\n\ndef bootstrap(settings):\n    return MyGreatEncryption(settings)\n\n\n\n\n\n\nFrom there, just test it out, and when you're ready, submit a \npull request!\n\n\nThat's Will's brain, end-to-end.  If you haven't already, dig into how to get him \ndeployed\n!", 
            "title": "Encryption and privacy"
        }, 
        {
            "location": "/backends/encryption/#encryption-backends", 
            "text": "", 
            "title": "Encryption Backends"
        }, 
        {
            "location": "/backends/encryption/#overview", 
            "text": "Encryption backends are what lets Will keep his thoughts private - safe from prying eyes, and would-be spies.  All of Will's short and long-term memory ( pubsub  and  storage ) are encrypted by default.  Will supports the following options for storage backend, and improvements and more backends are welcome:   AES ( will.backends.storage.aes ) - uses AES in CBC mode to encrypt.", 
            "title": "Overview"
        }, 
        {
            "location": "/backends/encryption/#choosing-a-backend", 
            "text": "Right now, your only option is AES.  So go with that! :)", 
            "title": "Choosing a backend"
        }, 
        {
            "location": "/backends/encryption/#setting-your-backend", 
            "text": "To set your backend, in  config.py , set:  # Turn on/off encryption in pub/sub and storage (default is on).\n# Causes a small speed bump, but secures messages in an untrusted environment.\n# ENABLE_INTERNAL_ENCRYPTION = True\nENCRYPTION_BACKEND =  aes", 
            "title": "Setting your backend"
        }, 
        {
            "location": "/backends/encryption/#contributing-a-new-backend", 
            "text": "Writing a new encryption backend is easy (if you've got the encryption stuff sorted.) Just subclass  BaseStorageBackend , and implement:   encrypt_to_b64  - a method that take an arbitary python object, and returns an encrypted, base64 string.  decrypt_from_b64  - a method that takes that base64 string, and returns a python object.  Provide a  bootstrap()  method that returns an instantiated EncryptionClass.   Here's an example:   from will.backends.storage.base import BaseStorageBackend\n\n\nclass MyGreatEncryption(WillBaseEncryptionBackend):\n\n    @classmethod\n    def encrypt_to_b64(cls, raw):\n        return binascii.b2a_base64(my_encryption_method(pickle.dumps(raw, -1)))\n\n    @classmethod\n    def decrypt_from_b64(cls, raw_enc):\n        return pickle_loads(binascii.a2b_base64(my_decryption_method(raw_enc)))\n\ndef bootstrap(settings):\n    return MyGreatEncryption(settings)  From there, just test it out, and when you're ready, submit a  pull request!  That's Will's brain, end-to-end.  If you haven't already, dig into how to get him  deployed !", 
            "title": "Contributing a new backend"
        }, 
        {
            "location": "/deploy/", 
            "text": "Deploying your Will\n\n\nWill's happy to run on your machine all day, every day.  But he really shines out in production where he can run independently of anything you do with your local machine.  Here are some best practices for deploying will.\n\n\nDeploy on Heroku\n\n\nHeroku is our recommended platform for deployment because it's simple, easy, and free. That's a tough combination to beat.  You're in no way locked in to running will on heroku, though - run him wherever you want!\n\n\nStep 1: Set up your heroku app, and a redis addon.\n\n\nAssuming you have the \nheroku toolbelt\n installed and all set up, it's as easy as this:\n\n\nheroku create our-will-name\nheroku addons:add rediscloud\n\n\n\n\nA note on rediscloud: you can also use redistogo, openredis, or anyone else.  We use rediscloud and like them.\n\n\nStep 2: Add all the needed environment variables:\n\n\nYou'll want to take all the variables that live in your virtualenv's \npostactivate\n file that feed into your will environment, and provide them to your heroku app.\n\n\nAt minimum, that's\n\n\nheroku config:set \\\nWILL_PUBLIC_URL=\nhttp://our-will-name.herokuapp.com\n \\\n# Slack\nWILL_SLACK_API_TOKEN=\nlkasjflkaklfjlasfjal1249814\n\n# Hipchat\nWILL_HIPCHAT_USERNAME='12345_123456@chat.hipchat.com' \\\nWILL_HIPCHAT_PASSWORD='asj2498q89dsf89a8df' \\\nWILL_HIPCHAT_V2_TOKEN='asdfjl234jklajfa3azfasj3afa3jlkjiau' \\\n# Rocket.Chat\nWILL_ROCKETCHAT_USERNAME='will@heywill.io'\\\nWILL_ROCKETCHAT_PASSWORD='12o312938asfjilasdlfjasdlkfj'\\\nWILL_ROCKETCHAT_URL='https://heywill.rocket.chat'\\\n\n\n\n\nFinally, for will's schedule to be correct, you need to set him to the time zone you want:\n\n\nheroku config:set TZ=\nAmerica/Los_Angeles\n\n\n\n\n\nNote:\n You don't have to worry about setting the \nREDIS_URL\n or \nHTTPSERVER_PORT\n.  Will auto-detects those and takes care of it.\n\n\nStep 3: Deploy!\n\n\nYou're all set to deploy your will. Ready? Go!\n\n\ngit push heroku\n\n\n\n\nYou app is now up on heroku.  Finally, turn it on!\n\n\nheroku scale web=1\n\n\nThat should be it - head over to \nhttp://our-will-name.herokuapp.com\n, and you should see will's smiling face.\n\n\nIf so, pop into chat, and give a:\n\n\n\n\nDeploying future updates\n\n\nJust commit your updates, then\n\n\ngit push heroku\n\n\n\n\nSimple.  For best-practices, see our continuous deployment recommendations below.\n\n\nDeploy in Docker\n\n\nWill is packaged with a Dockerfile and docker-compose files to allow deploying in a container with redis.\n\n\nPre-requisites\n\n\nYou should have docker already installed; additionally, the instructions require docker-compose.  If you're not using docker-compose, you can still also the \npre-defined images from Docker Hub\n. \n\n\nStep 1: Configure your container's environment variables\n\n\nIn Will's docker directory, update the default.env file with your environment's settings.  At a minimum, this should contain:\n\n\n# For Slack\nWILL_SLACK_API_TOKEN\n# For Hipchat\nWILL_HIPCHAT_USERNAME\nWILL_HIPCHAT_PASSWORD\nWILL_HIPCHAT_V2_TOKEN\n# Rocket.Chat\nWILL_ROCKETCHAT_USERNAME\nWILL_ROCKETCHAT_PASSWORD\nWILL_ROCKETCHAT_URL\n\n\n\n\nNote, we've pre-defined the redis url and the HTTP Server port; if you update these values, make sure you update the docker-compose file accordingly.\n\n\nStep 2: Deploy your plugins and templates\n\n\nIf you have any custom templates, create directories for your plugins and templates, and load your plugins and templates they'll be mounted when the container starts up giving your containerized bot access to your templates.\n\n\nmkdir ./plugins ./templates\n\n\n\n\nStep 3: Build will.\n\n\nRun build your docker image locally.\n\n\ndocker-compose build\n\n\n\n\nStep 4: Start the container\n\n\nStart your image from docker-compose using:\n\n\ndocker-compose up\n\n\n\n\nor to run the container in the background,\n\n\ndocker-compose up -d\n\n\n\n\nRoll your Own Container\n\n\nWill docker file(s) are part of the main repository; this lets developers/teams\nbuild on the containers to embed configuration files, custom plugins etc... For\nnow Will containers are represented in python 2.7 and python 3 flavors.\n\n\nWill-base\n\n\nWill is built on the alpine distribution(s) of python docker images. This was done\nto provide the smallest container footprint; yet, nothing is perfect so a few\nthings need to be added.  Will-base provides the foundation to perform these base\nmodifications.  \n\n\nWill\n\n\nThe heywill/will image is the container with Will executing as the\ncontainer process.  A build args are available for branch based builds from a\nrepository.  To build from a specific repo and branch use, \n\n\n--build-arg repo=\nrepo_name\n branch=\nbranch_name\n\n\n\n\n\notherwise skoczen/will is the default repo, while  master is the default branch.\n\n\nDeploy Everywhere Else\n\n\nWill is Just Python\n\n\nThat says it all. Will is just python, and you can deploy him \nanywhere\n you have python, an open port, and access to redis.\n\n\nIn your chosen deploy environment and setup, you'll want to do a couple things:\n\n\nReplicate your environment settings\n\n\nAt minimum, that's:\n\n\nexport WILL_PUBLIC_URL=\nhttp://our-will-name.herokuapp.com\n\nexport WILL_REDIS_URL='redis://some-domain.com/7/'\nexport WILL_HTTPSERVER_PORT='80'\n\n# Slack\nWILL_SLACK_API_TOKEN=\nlkasjflkaklfjlasfjal1249814\n\n# Hipchat\nexport WILL_HIPCHAT_USERNAME='12345_123456@chat.hipchat.com'\nexport WILL_HIPCHAT_PASSWORD='asj2498q89dsf89a8df'\nexport WILL_HIPCHAT_V2_TOKEN='asdfjl234jklajfa3azfasj3afa3jlkjiau'\n# Rocket.Chat\nWILL_ROCKETCHAT_USERNAME='will@heywill.io'\nWILL_ROCKETCHAT_PASSWORD='12o312938asfjilasdlfjasdlkfj'\nWILL_ROCKETCHAT_URL='https://heywill.rocket.chat'\n\n\n\n\nIf you have more than 30 chat rooms, you must also set the V1 token to avoid hipchat rate limits:\n\n\nexport WILL_HIPCHAT_V1_TOKEN='kjadfj89a34878adf78789a4fae3'\n\n\n\n\nYou'll also need to set any environment variables for your plugins.\n\n\nCall run_will with something that handles restarts and crashes.\n\n\nThe command to kick off will is just:\n\n\npython run_will.py\n\n\n\n\nYou can run that with whatever supervisory process you'd like. Will's very, very stable, but having something that handles crashes is still a pretty good idea.\n\n\nAlternate approach\n\n\nAh, you say, but I have this crazy python-twisted-zope-node monolith that self-repairs mars and can do everything. Why do I need the shell at all?\n\n\nAnswer, crazy monolith mars person: you don't.  Will is Just Python.\n\n\nfrom will.main import WillBot\n\nbot = WillBot()\nbot.bootstrap()\n\n\n\n\nand you're good.\n\n\nStorage Backends\n\n\nWill's default storage backend is Redis, but he supports some others if you can't run Redis.\n\n\nTo change the backend, just set \nSTORAGE_BACKEND\n in \nconfig.py\n and then supply any other needed settings for the new storage backend.  The currently supported backends are:\n\n\n\n\nredis\n - The default Redis backend\n\n\ncouchbase\n - A Couchbase backend\n\n\nfile\n - Keeps the settings as files on a local filesystem\n\n\n\n\nCouchbase\n\n\nCouchbase requries you set \nCOUCHBASE_URL\n in your config.\n\n\nYou are also required to have the python Couchbase client (and thus, libcouchbase) installed.  If you are installing for development you can use \npip install -r requirements.couchbase.txt\n to pull in the Couchbase client.  See \nthe Python Couchbase client repo\n for more info.\n\n\nExamples:\n\n\n\n\nCOUCHBASE_URL='couchbase:///bucket'\n\n\nCOUCHBASE_URL='couchbase://hostname/bucket'\n\n\nCOUCHBASE_URL='couchbase://host1,host2/bucket'\n\n\nCOUCHBASE_URL='couchbase://hostname/bucket?password=123abc\ntimeout=5'\n\n\n\n\nFile\n\n\nFile requires you set \nFILE_DIR\n in your config to point to an empty directory.\n\n\nExamples:\n\n\n\n\nFILE_DIR='/var/run/will/settings/'\n\n\nFILE_DIR='~will/settings/'\n\n\n\n\nPubsub Backends\n\n\nWill's default pubsub backend is Redis, and support for ZeroMQ and a pure-python backend is on the way.\n\n\nTo change the backend, just set \nPUBSUB_BACKEND\n in \nconfig.py\n and then supply any other needed settings for the new backend.  The currently supported backend is:\n\n\n\n\nredis\n - The default Redis backend\n\n\n\n\nBest Practices\n\n\nIn this section, we describe how we deploy and host will, in the hopes that others come forward and share what's working for them, too.  The more good practices, the better.\n\n\nOur Stack\n\n\nWe host on heroku, using rediscloud for redis, mailgun for email, and things have been peachy.  We deploy via CD using CircleCI. Details on that below.\n\n\nUse Continuous Deployment\n\n\nOur stack is set up so that any pushes on will's master branch have tests run on \nCircleCI\n, and if they pass, a new version is deployed to heroku immediately.  This has been delightful. Even though will has very, very minimal tests, we generally catch if things are horribly broken, and it's meant that adding new functionality to will takes minutes, sometimes seconds of developer time.\n\n\nContinuous Deployment has dramatically changed how we build and use will - instead of talking about \"what if will did...\", generally, people just implement it, push it, and play with it for real.  It's been a great place to be.  It might be for you too.\n\n\nThat's it in getting your will up and running!   But maybe you're one of those people who wants to pitch in and make will even better. Awesome. Learn \nhow to improve will\n.", 
            "title": "Deploy"
        }, 
        {
            "location": "/deploy/#deploying-your-will", 
            "text": "Will's happy to run on your machine all day, every day.  But he really shines out in production where he can run independently of anything you do with your local machine.  Here are some best practices for deploying will.", 
            "title": "Deploying your Will"
        }, 
        {
            "location": "/deploy/#deploy-on-heroku", 
            "text": "Heroku is our recommended platform for deployment because it's simple, easy, and free. That's a tough combination to beat.  You're in no way locked in to running will on heroku, though - run him wherever you want!", 
            "title": "Deploy on Heroku"
        }, 
        {
            "location": "/deploy/#step-1-set-up-your-heroku-app-and-a-redis-addon", 
            "text": "Assuming you have the  heroku toolbelt  installed and all set up, it's as easy as this:  heroku create our-will-name\nheroku addons:add rediscloud  A note on rediscloud: you can also use redistogo, openredis, or anyone else.  We use rediscloud and like them.", 
            "title": "Step 1: Set up your heroku app, and a redis addon."
        }, 
        {
            "location": "/deploy/#step-2-add-all-the-needed-environment-variables", 
            "text": "You'll want to take all the variables that live in your virtualenv's  postactivate  file that feed into your will environment, and provide them to your heroku app.  At minimum, that's  heroku config:set \\\nWILL_PUBLIC_URL= http://our-will-name.herokuapp.com  \\\n# Slack\nWILL_SLACK_API_TOKEN= lkasjflkaklfjlasfjal1249814 \n# Hipchat\nWILL_HIPCHAT_USERNAME='12345_123456@chat.hipchat.com' \\\nWILL_HIPCHAT_PASSWORD='asj2498q89dsf89a8df' \\\nWILL_HIPCHAT_V2_TOKEN='asdfjl234jklajfa3azfasj3afa3jlkjiau' \\\n# Rocket.Chat\nWILL_ROCKETCHAT_USERNAME='will@heywill.io'\\\nWILL_ROCKETCHAT_PASSWORD='12o312938asfjilasdlfjasdlkfj'\\\nWILL_ROCKETCHAT_URL='https://heywill.rocket.chat'\\  Finally, for will's schedule to be correct, you need to set him to the time zone you want:  heroku config:set TZ= America/Los_Angeles   Note:  You don't have to worry about setting the  REDIS_URL  or  HTTPSERVER_PORT .  Will auto-detects those and takes care of it.", 
            "title": "Step 2: Add all the needed environment variables:"
        }, 
        {
            "location": "/deploy/#step-3-deploy", 
            "text": "You're all set to deploy your will. Ready? Go!  git push heroku  You app is now up on heroku.  Finally, turn it on!  heroku scale web=1  That should be it - head over to  http://our-will-name.herokuapp.com , and you should see will's smiling face.  If so, pop into chat, and give a:", 
            "title": "Step 3: Deploy!"
        }, 
        {
            "location": "/deploy/#deploying-future-updates", 
            "text": "Just commit your updates, then  git push heroku  Simple.  For best-practices, see our continuous deployment recommendations below.", 
            "title": "Deploying future updates"
        }, 
        {
            "location": "/deploy/#deploy-in-docker", 
            "text": "Will is packaged with a Dockerfile and docker-compose files to allow deploying in a container with redis.", 
            "title": "Deploy in Docker"
        }, 
        {
            "location": "/deploy/#pre-requisites", 
            "text": "You should have docker already installed; additionally, the instructions require docker-compose.  If you're not using docker-compose, you can still also the  pre-defined images from Docker Hub .", 
            "title": "Pre-requisites"
        }, 
        {
            "location": "/deploy/#step-1-configure-your-containers-environment-variables", 
            "text": "In Will's docker directory, update the default.env file with your environment's settings.  At a minimum, this should contain:  # For Slack\nWILL_SLACK_API_TOKEN\n# For Hipchat\nWILL_HIPCHAT_USERNAME\nWILL_HIPCHAT_PASSWORD\nWILL_HIPCHAT_V2_TOKEN\n# Rocket.Chat\nWILL_ROCKETCHAT_USERNAME\nWILL_ROCKETCHAT_PASSWORD\nWILL_ROCKETCHAT_URL  Note, we've pre-defined the redis url and the HTTP Server port; if you update these values, make sure you update the docker-compose file accordingly.", 
            "title": "Step 1: Configure your container's environment variables"
        }, 
        {
            "location": "/deploy/#step-2-deploy-your-plugins-and-templates", 
            "text": "If you have any custom templates, create directories for your plugins and templates, and load your plugins and templates they'll be mounted when the container starts up giving your containerized bot access to your templates.  mkdir ./plugins ./templates", 
            "title": "Step 2: Deploy your plugins and templates"
        }, 
        {
            "location": "/deploy/#step-3-build-will", 
            "text": "Run build your docker image locally.  docker-compose build", 
            "title": "Step 3: Build will."
        }, 
        {
            "location": "/deploy/#step-4-start-the-container", 
            "text": "Start your image from docker-compose using:  docker-compose up  or to run the container in the background,  docker-compose up -d", 
            "title": "Step 4: Start the container"
        }, 
        {
            "location": "/deploy/#roll-your-own-container", 
            "text": "Will docker file(s) are part of the main repository; this lets developers/teams\nbuild on the containers to embed configuration files, custom plugins etc... For\nnow Will containers are represented in python 2.7 and python 3 flavors.", 
            "title": "Roll your Own Container"
        }, 
        {
            "location": "/deploy/#will-base", 
            "text": "Will is built on the alpine distribution(s) of python docker images. This was done\nto provide the smallest container footprint; yet, nothing is perfect so a few\nthings need to be added.  Will-base provides the foundation to perform these base\nmodifications.", 
            "title": "Will-base"
        }, 
        {
            "location": "/deploy/#will", 
            "text": "The heywill/will image is the container with Will executing as the\ncontainer process.  A build args are available for branch based builds from a\nrepository.  To build from a specific repo and branch use,   --build-arg repo= repo_name  branch= branch_name   otherwise skoczen/will is the default repo, while  master is the default branch.", 
            "title": "Will"
        }, 
        {
            "location": "/deploy/#deploy-everywhere-else", 
            "text": "", 
            "title": "Deploy Everywhere Else"
        }, 
        {
            "location": "/deploy/#will-is-just-python", 
            "text": "That says it all. Will is just python, and you can deploy him  anywhere  you have python, an open port, and access to redis.  In your chosen deploy environment and setup, you'll want to do a couple things:", 
            "title": "Will is Just Python"
        }, 
        {
            "location": "/deploy/#replicate-your-environment-settings", 
            "text": "At minimum, that's:  export WILL_PUBLIC_URL= http://our-will-name.herokuapp.com \nexport WILL_REDIS_URL='redis://some-domain.com/7/'\nexport WILL_HTTPSERVER_PORT='80'\n\n# Slack\nWILL_SLACK_API_TOKEN= lkasjflkaklfjlasfjal1249814 \n# Hipchat\nexport WILL_HIPCHAT_USERNAME='12345_123456@chat.hipchat.com'\nexport WILL_HIPCHAT_PASSWORD='asj2498q89dsf89a8df'\nexport WILL_HIPCHAT_V2_TOKEN='asdfjl234jklajfa3azfasj3afa3jlkjiau'\n# Rocket.Chat\nWILL_ROCKETCHAT_USERNAME='will@heywill.io'\nWILL_ROCKETCHAT_PASSWORD='12o312938asfjilasdlfjasdlkfj'\nWILL_ROCKETCHAT_URL='https://heywill.rocket.chat'  If you have more than 30 chat rooms, you must also set the V1 token to avoid hipchat rate limits:  export WILL_HIPCHAT_V1_TOKEN='kjadfj89a34878adf78789a4fae3'  You'll also need to set any environment variables for your plugins.", 
            "title": "Replicate your environment settings"
        }, 
        {
            "location": "/deploy/#call-run_will-with-something-that-handles-restarts-and-crashes", 
            "text": "The command to kick off will is just:  python run_will.py  You can run that with whatever supervisory process you'd like. Will's very, very stable, but having something that handles crashes is still a pretty good idea.", 
            "title": "Call run_will with something that handles restarts and crashes."
        }, 
        {
            "location": "/deploy/#alternate-approach", 
            "text": "Ah, you say, but I have this crazy python-twisted-zope-node monolith that self-repairs mars and can do everything. Why do I need the shell at all?  Answer, crazy monolith mars person: you don't.  Will is Just Python.  from will.main import WillBot\n\nbot = WillBot()\nbot.bootstrap()  and you're good.", 
            "title": "Alternate approach"
        }, 
        {
            "location": "/deploy/#storage-backends", 
            "text": "Will's default storage backend is Redis, but he supports some others if you can't run Redis.  To change the backend, just set  STORAGE_BACKEND  in  config.py  and then supply any other needed settings for the new storage backend.  The currently supported backends are:   redis  - The default Redis backend  couchbase  - A Couchbase backend  file  - Keeps the settings as files on a local filesystem", 
            "title": "Storage Backends"
        }, 
        {
            "location": "/deploy/#couchbase", 
            "text": "Couchbase requries you set  COUCHBASE_URL  in your config.  You are also required to have the python Couchbase client (and thus, libcouchbase) installed.  If you are installing for development you can use  pip install -r requirements.couchbase.txt  to pull in the Couchbase client.  See  the Python Couchbase client repo  for more info.  Examples:   COUCHBASE_URL='couchbase:///bucket'  COUCHBASE_URL='couchbase://hostname/bucket'  COUCHBASE_URL='couchbase://host1,host2/bucket'  COUCHBASE_URL='couchbase://hostname/bucket?password=123abc timeout=5'", 
            "title": "Couchbase"
        }, 
        {
            "location": "/deploy/#file", 
            "text": "File requires you set  FILE_DIR  in your config to point to an empty directory.  Examples:   FILE_DIR='/var/run/will/settings/'  FILE_DIR='~will/settings/'", 
            "title": "File"
        }, 
        {
            "location": "/deploy/#pubsub-backends", 
            "text": "Will's default pubsub backend is Redis, and support for ZeroMQ and a pure-python backend is on the way.  To change the backend, just set  PUBSUB_BACKEND  in  config.py  and then supply any other needed settings for the new backend.  The currently supported backend is:   redis  - The default Redis backend", 
            "title": "Pubsub Backends"
        }, 
        {
            "location": "/deploy/#best-practices", 
            "text": "In this section, we describe how we deploy and host will, in the hopes that others come forward and share what's working for them, too.  The more good practices, the better.", 
            "title": "Best Practices"
        }, 
        {
            "location": "/deploy/#our-stack", 
            "text": "We host on heroku, using rediscloud for redis, mailgun for email, and things have been peachy.  We deploy via CD using CircleCI. Details on that below.", 
            "title": "Our Stack"
        }, 
        {
            "location": "/deploy/#use-continuous-deployment", 
            "text": "Our stack is set up so that any pushes on will's master branch have tests run on  CircleCI , and if they pass, a new version is deployed to heroku immediately.  This has been delightful. Even though will has very, very minimal tests, we generally catch if things are horribly broken, and it's meant that adding new functionality to will takes minutes, sometimes seconds of developer time.  Continuous Deployment has dramatically changed how we build and use will - instead of talking about \"what if will did...\", generally, people just implement it, push it, and play with it for real.  It's been a great place to be.  It might be for you too.  That's it in getting your will up and running!   But maybe you're one of those people who wants to pitch in and make will even better. Awesome. Learn  how to improve will .", 
            "title": "Use Continuous Deployment"
        }, 
        {
            "location": "/improve/", 
            "text": "Making Will Better and Better\n\n\nWill is built entirely on the shoulders of giants, and has a great community of developers that move it forward. He wouldn't exist without all of them.\n\n\nWe also welcome new contributions no matter how big or small.  Interested in contributing to will? We'd love to have you. Details below.\n\n\nOur Culture\n\n\nAnyone is welcome to contribute to will, regardless of skill level or experience.  To make will the best he can be, we have one big, overriding cultural principle:\n\n\nBe kind.\n\n\nSimple.  Easy, right?\n\n\nWe've all been newbie coders, we've all had bad days, we've all been frustrated with libraries, we've all spoken a language we learned later in life.  In discussions with other coders, PRs, and CRs, we just give each the benefit of the doubt, listen well, and assume best intentions.  It's worked out fantastically.\n\n\nThis doesn't mean we don't have honest, spirited discussions about the direction to move will forward, or how to implement a feature.  We do.  We just respect one other while we do it.  Not so bad, right? :)\n\n\nImprove will's core\n\n\nFor big core features, you're probably best off opening an issue, and discussing it with one of the core developers \nbefore\n you hack your nights and weekends away.\n\n\nCore changes to will are very much welcome.  In some cases, proposed changes have already been thought through, and there may be gotchas or sticking points we couldn't get past.  In other cases, it might be a direction we've purposely decided not to take will.  In most cases, we simply haven't thought of it, and would love the improvement!\n\n\nIt's always great to get a heads up of what's coming down the pipe, and have an open dialog.  Thanks for reaching out and starting one!\n\n\nIn terms of the mechanics, you'll just want to:\n\n\n\n\nFork this repo.\n\n\nClone down a copy, set up redis and the env, as before.\n\n\nRun \n./start_dev_will.py\n to start up just core will.\n\n\n\n\nContribute new plugins\n\n\nThis one's pretty simple. Write good, clean code that does one thing well, document it properly, and submit a PR!\n\n\nTo submit a plugin that's running in your will,\n\n\n\n\nFork this repo.\n\n\nClone down a copy, set up redis and the env, as before.\n\n\npip install -r requirements.dev.txt\n\n\nCopy your plugin and docs over to the core will repo,\n\n\nRun \n./start_dev_will.py\n to start up just core will, and test it out!\n\n\n\n\nCode standards and PRs\n\n\nThis one's hopefully straightforward:\n\n\n\n\nIncoming code should follow PEP8\n\n\nIf you add new core-level features, please add documentation in the \ndocs\n folder (we use mkdocs).  If you're not sure if they're needed, just ask!\n\n\nPlease add your name and attribution to the AUTHORS file.\n\n\nKnow you have our thanks for helping to make will even better!\n\n\n\n\nTests\n\n\nShamefully, tests are just getting rolling, and a proper, well-architected test harness is in the works. However, there are \nsome\n tests you can run by running:\n\n\ntox\n\n\n\n\nMore soon!\n\n\nThe Shoulders of Giants\n\n\nWill leverages some fantastic libraries.  He wouldn't exist without them.\n\n\n\n\nBottle\n for http handling,\n\n\nJinja\n for templating,\n\n\nSleekxmpp\n for listening to xmpp,\n\n\nnatural\n and \nparsedatetime\n for natural date parsing,\n\n\napscheduler\n for scheduled task parsing,\n\n\nRequests\n to make http sane.\n\n\n\n\nWill was originally written and is maintained by \nSteven Skoczen\n.  Credit to GreenKahuna (now defunct) and \nBuddyUp\n for supporting those efforts with on-the-job time.\n\n\nWill's also has had help from lots of coders. Alphabetically:\n\n\n\n\nacommasplice\n fixed up the programmer help, so it works again.\n\n\nadamcin\n gave you html support in 1-1 chats, using the new v2 API, and made bootstrapping more reliable.\n\n\nadamgilman\n gave you the friendly error messages when the hipchat key was invalid.\n\n\nantgel\n fixed the image plugin, for reals and added awesome documentation.\n\n\namckinley\n fixed a bug in the hipchat user list from missing params.\n\n\nbfhenderson\n removed dependence on the v1 token, and made help more friendly.\n\n\nborgstrom\n gave you beautifully architected storage backends, including support for couchbase and local storage.\n\n\nbrandonsturgeon\n jumped on hipchat's API-breaking change, and made will immune in a flash.  Improved the docs all over, too.\n\n\nBrianGallew\n improved the blacklist import mechanism, so blacklisted modules aren't even attempted to be imported, taught will to handle zombie users with grace, and fixed the file storage backend.\n\n\nbsvetchine\n fixed a bug with README generation.\n\n\nburan\n added HTML support to 1-1 messages.\n\n\ncarsongee\n pooled your redis connections.\n\n\ncamilonova\n fixed the \n@randomly\n decorator, and brought the joy of more pugs to your life.  He's also reported several important bugs.\n\n\nckcollab\n was one of the original contributors, when will was first built at GreenKahuna.\n\n\ncharlax\n gave us batch-get of rooms via the V2 API.\n\n\nchillipeper\n fixed up the max-size and handling of V2 rooms, and taught will how to use bottle's \ncustom_filters\n.\n\n\ncrccheck\n gave you friendly error messages if your \nWILL_ROOMS\n was wrong.\n\n\nd0ugal\n fixed up the docs to meet the new mkdocs standard.\n\n\ndanbourke\n submitted a fix for the \n2000 rooms bug, and kept Will happy.\n\n\nderek-adair\n found a solution for the duplicated 'hi' messages.\n\n\ndpoirier\n figured out how to properly ignore the initial catch-up messages, and gave you log-level control.\n\n\ndmuntean\n gave you proxy support, and kept it working..\n\n\nhobson\n made setup.py more robust across operating systems, and improved the docs.\n\n\nIronykins\n brought you urban dictionary support.\n\n\nkenden\n fixed up the redis docs for ubuntu/debian.\n\n\njbeluch\n found a bug with \nget_roster\n not populating in time.\n\n\njcdyer\n made the \n_available_rooms\n object consistent across API versions.\n\n\njessamynsmith\n was kind enough to port \ntalkbackbot\n over, at my request, then kept it updated through version changes.\n\n\njquast\n did the noble and oft unappreciated work of spelling fixes.\n\n\nkeNzi\n added shorten url function using bitly service.\n\n\nlevithomason\n was one of the original contributors, when will was first built at GreenKahuna.\n\n\nmark-adams\n cleaned up a Bitbucket typo.\n\n\nmattcl\n taught will to reconnect to Slack when hiccups occur.\n\n\nmike-love\n added Docker support to make running Will easier - and then re-updated it to support Will 2.x!\n\n\nhobson\n made setup.py more robust across operating systems, and improved the docs.\n\n\nneronmoon\n made it easier to mention will with non-standard case\n\n\nmichaeljoseph\n suggested improvements to setup and requirements.txt format.\n\n\nmrgrue\n added support for the hipchat server beta.\n\n\nmvanbaak\n brought you support for bitbucket uptime.\n\n\nnetjunkie\n fixed a duplicated help module, added an expire parameter to \nself.save()\n, added support for will watching hipchat's status, fixed some redis config bugs, and kept word game working on py3.\n\n\nostracon\n got chat room replies working for orgs with \n 1000 rooms.\n\n\npcurry\n added travis support.\n\n\npepedocs\n added friendly timestamps to the default logging output.\n\n\nPrideRage\n gave you access to a room's entire history, and suggested a better talkback regex.\n\n\nquixeybrian\n wrote the awesome new help system and stopped the rate limit nightmare.\n\n\nRegner\n upgraded the hiredis version to work on windows.\n\n\nrbp\n added the \nadmin_only\n argument, and fixed a bug with \nroom\n not being passed along properly to messages.\n\n\nshadow7412\n cleaned up a bunch of regex, and fixed up \nimage me\n after google pulled the free API.\n\n\nsivy\n added a config flag for disabling SSL, and the ability to look up a user by nickname.\n\n\ntenzer\n added python 3 support!\n\n\ntomokas\n fixed a bug in the \n@randomly\n decorator.\n\n\ntophsic\n made help friendlier, including plugin-specific help.\n\n\n@TaunoTinits\n fixed the \nget_room_from_message\n method in 2.x.\n\n\nwohali\n tracked down the annoying DNS thread issue, and got will on the right path.\n\n\nwoohgit\n added support for the v2 WorldWeatherOnline API, and fixed it when I broke it, and then fixed it again when they changed their endpoint.  He also taught will how to say his version number.  And \nremind ___ to ___ at ___\n.  Awesome. And fixed lots of docs.  And put the time zone with \"what time is it?\".  And then added an entire Pagerduty workflow.  And made message parsing more reliable.  And wrote the ACL support.  And even more doc fixes. And improvements on uptime monitoring edge cases. And kept Pagerduty working. And added \nappend\n and \npop\n list support. And ditched WorldWeatherOnline when it started to hurt. Yep.\n\n\nwontonst\n made it simple to have will reply to a specific room, and made reminders more friendly.\n\n\nwoparry\n made sure that Will could handle organizations with a massive (\n2000) number of rooms.\n\n\n\n\nOther Wills\n\n\nIf you're looking for plugin inspiration, here are some wills that are open-sourced:\n\n\n\n\nBuddyUp's will\n\n\nSkoczen's will\n\n\nedX's devops will\n\n\nedX's fun will\n\n\n\n\nNote:\n Have a will you've open-sourced? Please send it in a PR or Issue!  This list is tiny!\n\n\nCurious how Will's grown over the years?  \nCheck out the releases\n!", 
            "title": "Improve"
        }, 
        {
            "location": "/improve/#making-will-better-and-better", 
            "text": "Will is built entirely on the shoulders of giants, and has a great community of developers that move it forward. He wouldn't exist without all of them.  We also welcome new contributions no matter how big or small.  Interested in contributing to will? We'd love to have you. Details below.", 
            "title": "Making Will Better and Better"
        }, 
        {
            "location": "/improve/#our-culture", 
            "text": "Anyone is welcome to contribute to will, regardless of skill level or experience.  To make will the best he can be, we have one big, overriding cultural principle:  Be kind.  Simple.  Easy, right?  We've all been newbie coders, we've all had bad days, we've all been frustrated with libraries, we've all spoken a language we learned later in life.  In discussions with other coders, PRs, and CRs, we just give each the benefit of the doubt, listen well, and assume best intentions.  It's worked out fantastically.  This doesn't mean we don't have honest, spirited discussions about the direction to move will forward, or how to implement a feature.  We do.  We just respect one other while we do it.  Not so bad, right? :)", 
            "title": "Our Culture"
        }, 
        {
            "location": "/improve/#improve-wills-core", 
            "text": "For big core features, you're probably best off opening an issue, and discussing it with one of the core developers  before  you hack your nights and weekends away.  Core changes to will are very much welcome.  In some cases, proposed changes have already been thought through, and there may be gotchas or sticking points we couldn't get past.  In other cases, it might be a direction we've purposely decided not to take will.  In most cases, we simply haven't thought of it, and would love the improvement!  It's always great to get a heads up of what's coming down the pipe, and have an open dialog.  Thanks for reaching out and starting one!  In terms of the mechanics, you'll just want to:   Fork this repo.  Clone down a copy, set up redis and the env, as before.  Run  ./start_dev_will.py  to start up just core will.", 
            "title": "Improve will's core"
        }, 
        {
            "location": "/improve/#contribute-new-plugins", 
            "text": "This one's pretty simple. Write good, clean code that does one thing well, document it properly, and submit a PR!  To submit a plugin that's running in your will,   Fork this repo.  Clone down a copy, set up redis and the env, as before.  pip install -r requirements.dev.txt  Copy your plugin and docs over to the core will repo,  Run  ./start_dev_will.py  to start up just core will, and test it out!", 
            "title": "Contribute new plugins"
        }, 
        {
            "location": "/improve/#code-standards-and-prs", 
            "text": "This one's hopefully straightforward:   Incoming code should follow PEP8  If you add new core-level features, please add documentation in the  docs  folder (we use mkdocs).  If you're not sure if they're needed, just ask!  Please add your name and attribution to the AUTHORS file.  Know you have our thanks for helping to make will even better!", 
            "title": "Code standards and PRs"
        }, 
        {
            "location": "/improve/#tests", 
            "text": "Shamefully, tests are just getting rolling, and a proper, well-architected test harness is in the works. However, there are  some  tests you can run by running:  tox  More soon!", 
            "title": "Tests"
        }, 
        {
            "location": "/improve/#the-shoulders-of-giants", 
            "text": "Will leverages some fantastic libraries.  He wouldn't exist without them.   Bottle  for http handling,  Jinja  for templating,  Sleekxmpp  for listening to xmpp,  natural  and  parsedatetime  for natural date parsing,  apscheduler  for scheduled task parsing,  Requests  to make http sane.   Will was originally written and is maintained by  Steven Skoczen .  Credit to GreenKahuna (now defunct) and  BuddyUp  for supporting those efforts with on-the-job time.  Will's also has had help from lots of coders. Alphabetically:   acommasplice  fixed up the programmer help, so it works again.  adamcin  gave you html support in 1-1 chats, using the new v2 API, and made bootstrapping more reliable.  adamgilman  gave you the friendly error messages when the hipchat key was invalid.  antgel  fixed the image plugin, for reals and added awesome documentation.  amckinley  fixed a bug in the hipchat user list from missing params.  bfhenderson  removed dependence on the v1 token, and made help more friendly.  borgstrom  gave you beautifully architected storage backends, including support for couchbase and local storage.  brandonsturgeon  jumped on hipchat's API-breaking change, and made will immune in a flash.  Improved the docs all over, too.  BrianGallew  improved the blacklist import mechanism, so blacklisted modules aren't even attempted to be imported, taught will to handle zombie users with grace, and fixed the file storage backend.  bsvetchine  fixed a bug with README generation.  buran  added HTML support to 1-1 messages.  carsongee  pooled your redis connections.  camilonova  fixed the  @randomly  decorator, and brought the joy of more pugs to your life.  He's also reported several important bugs.  ckcollab  was one of the original contributors, when will was first built at GreenKahuna.  charlax  gave us batch-get of rooms via the V2 API.  chillipeper  fixed up the max-size and handling of V2 rooms, and taught will how to use bottle's  custom_filters .  crccheck  gave you friendly error messages if your  WILL_ROOMS  was wrong.  d0ugal  fixed up the docs to meet the new mkdocs standard.  danbourke  submitted a fix for the  2000 rooms bug, and kept Will happy.  derek-adair  found a solution for the duplicated 'hi' messages.  dpoirier  figured out how to properly ignore the initial catch-up messages, and gave you log-level control.  dmuntean  gave you proxy support, and kept it working..  hobson  made setup.py more robust across operating systems, and improved the docs.  Ironykins  brought you urban dictionary support.  kenden  fixed up the redis docs for ubuntu/debian.  jbeluch  found a bug with  get_roster  not populating in time.  jcdyer  made the  _available_rooms  object consistent across API versions.  jessamynsmith  was kind enough to port  talkbackbot  over, at my request, then kept it updated through version changes.  jquast  did the noble and oft unappreciated work of spelling fixes.  keNzi  added shorten url function using bitly service.  levithomason  was one of the original contributors, when will was first built at GreenKahuna.  mark-adams  cleaned up a Bitbucket typo.  mattcl  taught will to reconnect to Slack when hiccups occur.  mike-love  added Docker support to make running Will easier - and then re-updated it to support Will 2.x!  hobson  made setup.py more robust across operating systems, and improved the docs.  neronmoon  made it easier to mention will with non-standard case  michaeljoseph  suggested improvements to setup and requirements.txt format.  mrgrue  added support for the hipchat server beta.  mvanbaak  brought you support for bitbucket uptime.  netjunkie  fixed a duplicated help module, added an expire parameter to  self.save() , added support for will watching hipchat's status, fixed some redis config bugs, and kept word game working on py3.  ostracon  got chat room replies working for orgs with   1000 rooms.  pcurry  added travis support.  pepedocs  added friendly timestamps to the default logging output.  PrideRage  gave you access to a room's entire history, and suggested a better talkback regex.  quixeybrian  wrote the awesome new help system and stopped the rate limit nightmare.  Regner  upgraded the hiredis version to work on windows.  rbp  added the  admin_only  argument, and fixed a bug with  room  not being passed along properly to messages.  shadow7412  cleaned up a bunch of regex, and fixed up  image me  after google pulled the free API.  sivy  added a config flag for disabling SSL, and the ability to look up a user by nickname.  tenzer  added python 3 support!  tomokas  fixed a bug in the  @randomly  decorator.  tophsic  made help friendlier, including plugin-specific help.  @TaunoTinits  fixed the  get_room_from_message  method in 2.x.  wohali  tracked down the annoying DNS thread issue, and got will on the right path.  woohgit  added support for the v2 WorldWeatherOnline API, and fixed it when I broke it, and then fixed it again when they changed their endpoint.  He also taught will how to say his version number.  And  remind ___ to ___ at ___ .  Awesome. And fixed lots of docs.  And put the time zone with \"what time is it?\".  And then added an entire Pagerduty workflow.  And made message parsing more reliable.  And wrote the ACL support.  And even more doc fixes. And improvements on uptime monitoring edge cases. And kept Pagerduty working. And added  append  and  pop  list support. And ditched WorldWeatherOnline when it started to hurt. Yep.  wontonst  made it simple to have will reply to a specific room, and made reminders more friendly.  woparry  made sure that Will could handle organizations with a massive ( 2000) number of rooms.", 
            "title": "The Shoulders of Giants"
        }, 
        {
            "location": "/improve/#other-wills", 
            "text": "If you're looking for plugin inspiration, here are some wills that are open-sourced:   BuddyUp's will  Skoczen's will  edX's devops will  edX's fun will   Note:  Have a will you've open-sourced? Please send it in a PR or Issue!  This list is tiny!  Curious how Will's grown over the years?   Check out the releases !", 
            "title": "Other Wills"
        }, 
        {
            "location": "/releases/", 
            "text": "Releases\n\n\n2.1.1 - March 22, 2018\n\n\nBugfix release that includes:\n\n\n\n\nFixes slack reconnect issues, thanks to \n@mattcl\n.  Props to \n@cmachine\n for also submitting a fix.\n\n\nSaying \"G\" will no longer give you a picture of a pug, using the default settings. This is both tragic, and necessary. (Actual fix: adjusted default fuziness settings.  If you have the fuzzy backend on, and were seeing the rather hilarious/annoying \n#327\n, set \nFUZZY_MINIMUM_MATCH_CONFIDENCE = 91\n in your config.py)\n\n\nProgrammer help is working again, thanks to \n@acommasplice\n.\n\n\nFixes word game to work in python 3 thanks to \n@netjunki\n, and \nptomkiel-oktawave\n's report.\n\n\nFixes up chat room rosters in HipChat with rosters \n 1000 rooms, thanks to \n@ostracon\n\n\nFixes \nget_room_from_message\n, thanks to \n@TaunoTinits\n's fix and  \nptomkiel-oktawave\n's report.\n\n\nFixes an error that could occur on incoming webhooks on hipchat.  Thanks to \nptomkiel-oktawave\n and others for a report.\n\n\nFixes Will incorrectly talking to the main slack room, when he's directly addressed in 1-1 with something he doesn't know how to do.  Thanks to \nnetjunki\n for the report!\n\n\n\n\n2.1.0 - November 28, 2017\n\n\nPlanned release that includes:\n\n\n\n\nAutomatic \ndocker hub builds\n thanks to \n@mike-love\n\n\nUpgrades to use base markdownify package, as the proposed changes have been \nmerged and released\n.\n\n\nNew fabric commands to manage docker builds and releases.\n\n\n\n\n2.0.2 - November 22, 2017\n\n\nBugfix release that fixes:\n\n\n\n\nWill once again joins all hipchat rooms \nHIPCHAT_ROOMS\n was not specified.  Thanks to \nvissree\n for finding and reporting this bug!\n\n\n\n\n2.0.1 - November 21, 2017\n\n\nSame release as 2.0.1, removes beta tag.\n\n\n2.0.1beta4 - November 20, 2017\n\n\nBugfix release that fixes:\n\n\n\n\ncolor\n parameter wasn't working properly in Slack.\n\n\nFixes up slack escaping, to support \nslack formatted|https://example.com\n links.  Thanks to \n@netjunki\n for the report on this and the above.\n\n\n\n\nMinor features:\n* Adds a new \nstart_thread\n parameter to \nsay()\n and \nreply()\n to allow Will to start slack threads.\n\n\n2.0.1beta3 - November 13, 2017\n\n\nBugfix release that fixes:\n\n\n\n\nHigh CPU in some setups, thanks to \nmattcl\n for the report and debuggging!\n\n\nUpdates to \nmarkdownify\n fork 0.4.1.\n\n\n\n\n2.0.1beta2 - November 9, 2017\n\n\nBugfix release that fixes:\n\n\n\n\nFixes \nscheduled_say\n breakage.\n\n\nImproves reminder plugins to capture and naturally handle \"to\"s, thanks to \nwontonst\n.\n\n\nGets docker builds working, thanks to \nmike-love\n.\n\n\n\n\n2.0.1beta1 - November 7, 2017\n\n\nTL;DR: Slack, Rocket.chat, and Shell support, and you can write full chatterbots with Will now!\n\n\nThis is a huge rewrite of will, adding pluggable backends for chat systems, Will's internal brains, pub-sub, and encryption.  \n\n\nA huge number of really smart people gave their thoughts and suggestions throughout the process, not least \n@hobson\n, \n@woohgit\n, \n@netjunki\n, \n@sivy\n, \n@antgel\n, \n@shadow7412\n, \n@brandonsturgeon\n, \n@pepedocs\n, \n@tophsic\n, and \n@mike-love\n.\n\n\nRead all about what and why here: \nWhat's new in Will 2\n,\n\n\nAnd when you're ready to upgrade, here's \nthe upgrade guide\n. (Spoiler: \npip install -U will\n).\n\n\nHigh-level, here's what's new:\n\n\n\n\nSlack support\n\n\nCLI/Shell backend\n\n\nRocket.chat\n support, thanks to \nantgel\n.\n\n\nWill's brains have been abstracted - you can now add custom \nanalysis\n, \ngeneration\n, and \nexecution\n backends to build everything from a straight regex-bot to a full chatterbot.\n\n\nPluggable I/O backends\n, which is how all of the above were done, and which means adding new platforms is pretty simple.\n\n\nPluggable storage\n backends.\n\n\nPluggable pubsub\n backends.\n\n\nBuilt-in encryption for storage and pub/sub (with \npluggable backends\n as well.)\n\n\nLots more intelligence around required settings and verification, to make first starting and debugging Will easier.\n\n\nFull Python 3 support. (Don't worry, 2.x \nisn't going anywhere\n.)\n\n\nNew \n@will gif me\n command.  Because it can't all be serious. :)\n\n\n\n\nThis release also changes a few bits of behavior, to be consistent:\n\n\n\n\nself.reply()\n \nfinally\n no longer requires you to tediously pass the \nmessage\n back to it.  It's also smart, and backwards compatable with existing plugins.\n\n\nadmin_only\n is explicitly flagged for deprecation and removal, to be replaced by the ACL system introduced in 2015 (largely, this is because having two different access control systems is crazy and painful.)  Switching is as easy as adding \nACL = {'admins': ['steven', 'will']}\n to your config.py and find/replacing \nadmin_only=True\n with `acl=['admins',] in your codebase.  For now, Will handles backwards compatibility by mapping the old settings into the new places, but he won't forever.  Thanks for updating, and making ongoing maintenence simpler!\n\n\nIf no ACLs are specified and users try to perform restricted commands, they'll be allowed as before, but Will will complain to the console. A new \nDISABLE_ACL\n setting has been added to turn off the complaining.\n\n\nYou can pass in \nchannel=\n or \nroom=\n when specifying a custom reply location.  If both are passed in, Will uses \nchannel\n.\n\n\n\n\nThere are a couple \ninternal\n backwards-incompatible changes:\n\n\n\n\nRosterMixin\n has been renamed \nHipChatRosterMixin\n and moved to \nwill.backends.io_adapters.hipchat\n.  This change should not affect you unless you were specifically importing RosterMixin in your own plugins - everything in \nWillPlugin\n has been automatically routed to the right place, in a backwards-compatible way.\n\n\nRoom\n and \nRoomMixin\n have similarly become \nHipChatRoom\n and \nHipChatRoomMixin and moved to\nwill.backends.io_adapters.hipchat`.\n\n\n\n\nAs this is a \nbig\n update, please report any bugs you see (no matter how small) to \nthe github issue tracker\n.  Thanks in advance for making Will even better!\n\n\n1.0.2 - October 24, 2017\n\n\nFixes and features in this release:\n\n\n\n\nMakes passing the \nroom=\n option \nmuch\n easier (you can just use the room's name now,) thanks to \nwontonst\n.\n\n\nAdds support for jinja \ncustom_filters\n in the \n@rendered_template\n decorator, thanks to \nchillipeper\n.\n\n\n\n\n1.0.1 - October 10, 2017\n\n\nFixes and features in this release:\n\n\n\n\nFixes what time plugin to not require World Weather's old API, thanks to \nwoohgit\n.\n\n\nAdds Docker support, thanks to \nmike-love\n.\n\n\nAdds Python 3 support, thanks to \ntenzer\n.\n\n\n\n\n1.0.0 - September 29, 2017\n\n\nThis is the end of major feature development for the hipchat-only version of Will.  Future development will be on 2.x, and while backwards compatability will be aimed for, it's not 100% guaranteed.\n\n\nFixes and features in this release:\n\n\n\n\nMakes ACLs be case-insensitive, thanks to \nwoohgit\n.\n\n\nAdds Hipchat card support, also thanks to \nwoohgit\n.\n\n\nGets Chatoms random topics working again, thanks to \nbykof\n.\n\n\nEnvironment overrides for \nPLUGINS\n and \nPLUGIN_BLACKLIST\n (semicolon separated) are now possible, thanks to \nmark-adams\n.\n\n\n\n\n0.9.5 - June 23, 2017\n\n\nQuick bugfix release before the big changeover to 1.0, pluggable backends (Slack support), and more.\n\n\n\n\nFixed: \n@will image me\n actually works again thanks to \nantgel\n.\n\n\n\n\n0.9.4 - April 25, 2017\n\n\nNew releases and movement again!  Exciting things in the pipeline for will, and that's starting with a long-awaited release.  Thanks to everyone who both submitted code, and had saint-like patience with it being merged in.\n\n\n\n\nNew: \nself.append()\n and \nself.pop()\n methods to support list storage, thanks to \nwoohgit\n.\n\n\nFixed: \n@will image me\n works again (but requires a google API key - see \nconfig.py\n, thanks to \nshadow7412\n.\n\n\nFixed: \n@will pugs\n thankfully works again, thanks to \ngordol\n.\n\n\nImprovement: \n@will help \nplugin\n now gives plugin-specific help, thanks to \ntophsic\n.\n\n\nImprovement: Blacklisted modules aren't even attempted to be imported, thanks to \nBrianGallew\n.\n\n\nImprovement: File storage engine expires properly, thanks to \nBrianGallew\n.\n\n\nImprovement: Zombie users no longer cause will trouble, thanks to \nBrianGallew\n.\n\n\nImprovement: Will now no longer gets stuck if organizations have more than 2000(!) hipchat rooms, courtesy of \nwoparry\n and \ndanbourke\n.\n\n\nImprovement: V2 API calls for multiple rooms now properly uses \nmax-results\n and doesn't hang, thanks to \nchillipeper\n.\n\n\nImprovement: Much-improved test runners, and proper case for Bitbucket, thanks to \nmark-adams\n.\n\n\nImprovement: \n_available_rooms\n is now populated with \nRoom\n objects, regardless of whether you use V1 or V2, thanks to \njcdyer\n.\n\n\nImprovement: Output logging now includes timestamps by default, thanks to \npepedocs\n.\n\n\nImprovement: Upgraded to \nhiredis\n \n 0.2 to get windows builds working, thanks to \nRegner\n.\n\n\nImprovement: Updated to the new pagerduty docs, thanks to \nwoohgit\n.\n\n\nImprovement: Generation script doesn't make a duplicate \nhi\n response, thanks to \nbrandonsturgeon\n and \nderek-adair\n.\n\n\n\n\n0.9.3 - September 11, 2015\n\n\nThanks for your patience on this long-delayed release!  Here's what's new:\n\n\n\n\nNew: Will watches bitbucket, and alerts on downtime, thanks to \nmvanbaak\n.\n\n\nNew: \n@will urban dictionary ______\n, thanks to \nIronykins\n.\n\n\nNew: 1-1 messages now support HTML, thanks to \nAndrewBurdyug\n and \nbrandonsturgeon\n\n\nImprovement: Batch-getting of rooms, thanks to \ncharlax\n.\n\n\nImprovement: Better handling of uptime check edge cases, thanks to \nwoohgit\n.\n\n\nImprovement: Proper docs for installing redis on ubuntu/debian, thanks to \nkenden\n.\n\n\nImprovement: Pulled an extraneous doc page, thanks to \nwoohgit\n.\n\n\nImprovement: Fixes to the route doc syntax, thanks to \nbrandonsturgeon\n.\n\n\nImprovement: Docs now fit the new mkdocs format, thanks to \nd0ugal\n.\n\n\nImprovement: New travis.yml setup for easier travis running, and plugged my CircleCI builds into the github repo. All future PRs should automatically have tests run!\n\n\n\n\n0.9.2 - June 5, 2015\n\n\n\n\nFixes bug that caused will not to join all rooms if \nROOMS\n was missing. Thanks to \ncamilonova\n for the report!\n\n\n\n\n0.9.1 - May 30, 2015\n\n\n\n\nFixes bug that affected \n@will\ns - thanks to \nwoohgit\n for the report!\n\n\n\n\n0.9 - May 29, 2015\n\n\n\n\nBREAKING:\n Module change. New \nwill.plugins.fun\n module. Existing will installs will need to add it to your \nconfig.py\n to keep the fun!\n\n\nNew:  Support for Pagerduty workflows, thanks to \nwoohgit\n. This is really tremendous stuff. \nCheck out the docs here\n!\n\n\nNew: \nPluggable storage backends\n, with support for couchbase and local file storage, in addition to redis.  Many thanks to \nborgstrom\n\n\nNew: \nACL\n functionality, thanks to \nwoohgit\n.  Backwards-compatable, even!\n\n\nNew: Made will a little more fun, thanks to \ncamilonova\n.  Hint: it involves the world's most meme-friendly dog.\n\n\nNew: Will can now construct google poems, thanks to \nAirbornePorcine\n. Truly, his creativity knows no bounds.\n\n\nImprovement: Moved stuff like that into a new \"fun\" module.  Dry, anti-fun people can now disable it more easily. ;)\n\n\nImprovement: \"What time is it\" now outputs time zones, thanks to \nwoohgit\n.\n\n\nImprovement: No more rate-limit problems on the v2 token, thanks to \ngrundprinzip\n.\n\n\nImprovement: Messages are now \n.strip()\ned before being compared, to handle \nfrozen-fingered-typos\n.  Thanks, \nwoohgit\n!\n\n\nFix: Typo in the docs gone.  Thanks, \nwoohgit\n.\n\n\nFix: Bugs in proxy support are fixed, thanks to \ndmuntean\n.\n\n\n\n\n0.8.2 - April 24, 2015\n\n\n\n\nFixes an odd remaining bug with \n@randomly\n, thanks to \ncamilonova\n's continued debugging.\n\n\n\n\n0.8.1 - April 23, 2015\n\n\n\n\nMoves \nversion\n plugin into admin, so it just works for most users.\n\n\n\n\n0.8 - April 23, 2015\n\n\n\n\nWhat happens when life gets busy and we go a full month and a half between will releases?  Lots and lots:\n\n\nNew: All-new \n@will who is in this room?\n command, thanks to \npuug\n.\n\n\nNew: Will now can shorten links via bitly \n@will bitly http://example.com\n, thanks to \nkeNzi\n.\n\n\nNew: Will now supports a \nPROXY_URL\n setting, for getting around funky firewalls, thanks to \ndmuntean\n.\n\n\nNew: \n@will version\n command to check version number, thanks to \nwoohgit\n.\n\n\nNew: Awesome new \nremind ___ to ___ at ___\n, thanks to \nwoohgit\n.\n\n\nNew: Will now keeps an eye on hipchat's uptime as well, thanks to \nnetjunki\n.\n\n\nFix: a breaking bug in the \n@randomly\n decorator, thanks to a report by \ncamilonova\n.\n\n\nSupport: Handles a breaking change in the hipchat API, thanks to \nbrandonsturgeon\n.\n\n\nSupport: Updates to v2 of the underquoted API, thanks \njessamynsmith\n.\n\n\nSupport: Updated to the new WorldWeatherOnline endpoint, since they had DDOS problems, thanks to \nwoohgit\n.\n\n\nImprovement: The most important kind of PRs.  Spelling fixes.  Many thanks to \njquast\n.\n\n\nImprovement: \nself.save()\n now accepts an \nexpire\n value, thanks to \nnetjunki\n.\n\n\nImprovement: PEP8 passes for the whole codebase, with flake8 added to automated tests.\n\n\n\n\n0.7.3 - March 3, 2015\n\n\n\n\nFixed a breaking bug to world time, thanks to \nwoohgit\n.\n\n\n\n\n0.7.2 - February 27, 2015\n\n\n\n\nImproved handling when \n.reply()\n is called incorrectly, thanks to a report by \ndothak\n\n\nFixed the \nannoying\n \"github's ok\" on first launch.\n\n\nRestored Python 2.6 compatability thanks to the report and patience of \nJPerkster\n.\n\n\nLots of code cleanup toward pep8.\n\n\n\n\n0.7.1 - February 5, 2015\n\n\n\n\nImproved talkbackbot regex, suggested by \nPrideRage\n.\n\n\n\n\n0.7.0 - February 4, 2015\n\n\n\n\nAdds a port of the awesome \ntalkbackbot\n, thanks to \njessamynsmith\n, who super-kindly ported it at my request!\n\n\nOh, yeah. That port also includes the first proper tests in will, and a pretty solid pattern for testing plugins.  Woo!  More huge thanks to \njessamynsmith\n.\n\n\n\n\n0.6.9 - January 30, 2015\n\n\n\n\nFixed copypasta error caught by the keen eye of \ndpoirier\n.\n\n\n\n\n0.6.8 - January 30, 2015\n\n\n\n\nWill now supports templates directories within plugins.  Just put a \ntemplates\n directory in the plugin's module, and it will be detected.  Thanks to \nsivy\n for the idea and willingness to get it done!\n\n\n\n\n0.6.7 - January 29, 2015\n\n\n\n\nAddition of \n.get_user_by_nick()\n method, to look up users by nick, thanks to \nsivy\n.\n\n\nBugfix to \nALLOW_INSECURE_HIPCHAT_SERVER\n when specified in \nconfig.py\n, thanks to \nsivy\n.\n\n\n\n\n0.6.6 - January 29, 2015\n\n\n\n\nNew \nroom.history\n attribute with a room's history, thanks to \nPrideRage\n\n\nNew setting: \nALLOW_INSECURE_HIPCHAT_SERVER\n, which will disable SSL checks (you're on your own), thanks to \nsivy\n.\n\n\nAdds support for V2 of the WorldWeatherOnline API (used for world times, weather) thanks to \nwoohgit\n.\n\n\nAdds new release and doc deploy scripts, so the github \nreleases\n are kept up to date.  Thanks to \ncrccheck\n for noticing and reporting they were stale!\n\n\n\n\n0.6.5 - January 23, 2015\n\n\n\n\nRemoves mkdocs from the production requirements.txt to fix a Jinja version problem.  Thanks to the report from \nPrideRage\n.\n\n\n\n\n0.6.4 - January 19, 2015\n\n\n\n\nSwitches to bottle to cherrypy over gevent, which should solve lingering gevent DNS threading issues, thanks to \nwohali\n.\n\n\nSupport for @will, @WILL, @wIll, thanks to \nneronmoon\n\n\n\n\n0.6.3 - December 30, 2014\n\n\n\n\nBetter error handling for weirdly formatted messages.\n\n\nBetter generated README, thanks to \nbsvetchine\n.\n\n\n\n\n0.6.2 - September 23, 2014\n\n\n\n\nBugfix on \ngenerate_will_project\n, thanks to the report by \nMattyDub\n.\n\n\n\n\n0.6.1 - September 23, 2014\n\n\n\n\nFreezes apscheduler to \n 3.0, since its API was backwards incompatibile.\n\n\n\n\n0.6.0 - September 17, 2014\n\n\n\n\nMethods in a single class now share a common instance, thanks to \namckinley\n.\n\n\nRedis connections are now pooled (which should help with \"max clients exceeded\" errors), thanks to \ncarsongee\n.\n\n\nPreliminary travis ci support, thanks to \npcurry\n.\n\n\nMore gramatically correct documentation by \nhobson\n.\n\n\n\n\n0.5.7 - September 3, 2014\n\n\n\n\nImprovements to setup.py to be robust a variety of linux/unixes by \nhobson\n.\n\n\n\n\n0.5.6 - August 26, 2014\n\n\n\n\nFix for 1-1 bootstrapping bug, thanks to \nadamcin\n.\n\n\n\n\n0.5.5 - August 25, 2014\n\n\n\n\nFull html support in 1-1 chats, thanks to \nadamcin\n.\n\n\n\n\n0.5.4 - July 22, 2014\n\n\n\n\nUpgrades bottle to 0.12.6 to fix \nsecurity bug\n.\n\n\n\n\n0.5.3 - July 11, 2014\n\n\n\n\n@randomly\n functions now can run on the 59th minute, thanks to \ntomokas\n.\n\n\nBad merge that duplicated \nhelp.py\n fixed by \nnetjunki\n.\n\n\n\"global name 'params' is not defined\" bug fixed by \namckinley\n.\n\n\n\n\n0.5.1 - July 2, 2014\n\n\n\n\nNew \nHIPCHAT_SERVER\n setting to support \nbeta HipChat Server\n, thanks to \nmrgrue\n.\n\n\n\n\n0.5 Omnibus - June 27, 2014\n\n\n\n\nBig, big release, with backwards-incompatble changes.  Please read all the notes on this one!\n\n\nAll-new config and environment setup, including an all-new \nconfig.py\n for plugin configuration, and all non-sensitive settings.\n\n\nMuch, much improved bootstrapping code that validates settings, gives helpful output, and generally helps you get will running.\n\n\nDocumentation!  Real-live documentation!\n\n\nBreaking\n: \nWILL_TOKEN\n has been renamed \nWILL_HIPCHAT_V1_TOKEN\n.\n\n\nNew \n@require_settings\n decorator for plugins to request validation that needed settings are present.\n\n\nWill now has a concept of modules (groups of plugins), and groups help output according.\n\n\n\n\n0.4.10 - June 6, 2014\n\n\n\n\nBrand-new \nadmin_only\n argument to \nhear()\n and \nrespond_to()\n, thanks to \nrbp\n.  If a user is not in \nWILL_ADMINS\n, they won't be able to run any \nadmin_only=True\n plugins.  Default for \nWILL_ADMINS\n is all users to retain backwards-compatibility.\n\n\nAll commands in the \nstorage.py\n plugin are now admin-only.\n\n\nhelp\n now only responds to direct asks, allowing other plugins to handle \"help me with x\", thanks to \nbfhenderson\n\n\n\n\n0.4.9 - May 28, 2014\n\n\n\n\nPassing a \nroom\n to a \n.say()\n now works properly, thanks to \nrbp\n.\n\n\nNew optional \nWILL_LOGLEVEL\n setting, thanks to \ndpoirier\n.\n\n\n\n\n0.4.8 - May 21, 2014\n\n\n\n\nWill now ignores all previously sent messages properly, by passing in \nbot\n as the resource instead of an ugly time hack, thanks to \ndpoirier\n.\n\n\n\n\n0.4.7 - May 15, 2014\n\n\n\n\nWill now prints a helpful message if one of your \nWILL_ROOMS\n is wrong, and continues starting, instead of crashing in a fiery ball, thanks to \ncrccheck\n.\n\n\n\n\n0.4.6 - May 5, 2014\n\n\n\n\n@route\n decorators now honor all bottle arguments, most helpfully \nmethod\n!\n\n\n\n\n0.4.5 - May 2, 2014\n\n\n\n\nAwesome new help system by \nquixeybrian\n.\n\n\n\"@will help\" now only displays functions with docstrings, and formats them nicely.\n\n\nOld help (regexes and all) is available at \"@will programmer help\"\n\n\n\n\n0.4.4 - April 22, 2014\n\n\n\n\nRemoves the dependence on the v1 token (though it still helps with rate-limiting), thanks to \nbfhenderson\n.\n\n\nMuch friendlier error message on an invalid API key, thanks to \nadamgilman\n.\n\n\n\n\n0.4.3 - ~ April 1, 2014\n\n\n\n\nSupport for hundreds of users and rooms without hitting the API limit.\n\n\nget_all_users\n use of the bulk API \nadded\n by \nquixeybrian\n.  Thanks also to \njbeluch\n and \njdrukman\n for nudges in the right direction.\n\n\nThe start of some useful comments - the meat of will was hacked out by one person over a handful of days and it looks that way. Slowly but surely making this codebase more friendly to other contributions!\n\n\nAdded a CONTRIBUTING.md file thanks to \nmichaeljoseph\n.\n\n\nProper releases in the docs, and an updated \nAUTHORS\n file.  If you see something awry, send a PR!\n\n\n\n\n0.4 - ~ March 2014\n\n\n\n\n\n\nYe olden past before we started keeping this list.  All contributions by GreenKahuna.  Will did everything that's not in the release list above.  That's called lazy retconning release lists!\n\n\n\n\n\n\nMake sure nothing from the readme is missed.", 
            "title": "Releases"
        }, 
        {
            "location": "/releases/#releases", 
            "text": "", 
            "title": "Releases"
        }, 
        {
            "location": "/releases/#211-march-22-2018", 
            "text": "Bugfix release that includes:   Fixes slack reconnect issues, thanks to  @mattcl .  Props to  @cmachine  for also submitting a fix.  Saying \"G\" will no longer give you a picture of a pug, using the default settings. This is both tragic, and necessary. (Actual fix: adjusted default fuziness settings.  If you have the fuzzy backend on, and were seeing the rather hilarious/annoying  #327 , set  FUZZY_MINIMUM_MATCH_CONFIDENCE = 91  in your config.py)  Programmer help is working again, thanks to  @acommasplice .  Fixes word game to work in python 3 thanks to  @netjunki , and  ptomkiel-oktawave 's report.  Fixes up chat room rosters in HipChat with rosters   1000 rooms, thanks to  @ostracon  Fixes  get_room_from_message , thanks to  @TaunoTinits 's fix and   ptomkiel-oktawave 's report.  Fixes an error that could occur on incoming webhooks on hipchat.  Thanks to  ptomkiel-oktawave  and others for a report.  Fixes Will incorrectly talking to the main slack room, when he's directly addressed in 1-1 with something he doesn't know how to do.  Thanks to  netjunki  for the report!", 
            "title": "2.1.1 - March 22, 2018"
        }, 
        {
            "location": "/releases/#210-november-28-2017", 
            "text": "Planned release that includes:   Automatic  docker hub builds  thanks to  @mike-love  Upgrades to use base markdownify package, as the proposed changes have been  merged and released .  New fabric commands to manage docker builds and releases.", 
            "title": "2.1.0 - November 28, 2017"
        }, 
        {
            "location": "/releases/#202-november-22-2017", 
            "text": "Bugfix release that fixes:   Will once again joins all hipchat rooms  HIPCHAT_ROOMS  was not specified.  Thanks to  vissree  for finding and reporting this bug!", 
            "title": "2.0.2 - November 22, 2017"
        }, 
        {
            "location": "/releases/#201-november-21-2017", 
            "text": "Same release as 2.0.1, removes beta tag.", 
            "title": "2.0.1 - November 21, 2017"
        }, 
        {
            "location": "/releases/#201beta4-november-20-2017", 
            "text": "Bugfix release that fixes:   color  parameter wasn't working properly in Slack.  Fixes up slack escaping, to support  slack formatted|https://example.com  links.  Thanks to  @netjunki  for the report on this and the above.   Minor features:\n* Adds a new  start_thread  parameter to  say()  and  reply()  to allow Will to start slack threads.", 
            "title": "2.0.1beta4 - November 20, 2017"
        }, 
        {
            "location": "/releases/#201beta3-november-13-2017", 
            "text": "Bugfix release that fixes:   High CPU in some setups, thanks to  mattcl  for the report and debuggging!  Updates to  markdownify  fork 0.4.1.", 
            "title": "2.0.1beta3 - November 13, 2017"
        }, 
        {
            "location": "/releases/#201beta2-november-9-2017", 
            "text": "Bugfix release that fixes:   Fixes  scheduled_say  breakage.  Improves reminder plugins to capture and naturally handle \"to\"s, thanks to  wontonst .  Gets docker builds working, thanks to  mike-love .", 
            "title": "2.0.1beta2 - November 9, 2017"
        }, 
        {
            "location": "/releases/#201beta1-november-7-2017", 
            "text": "TL;DR: Slack, Rocket.chat, and Shell support, and you can write full chatterbots with Will now!  This is a huge rewrite of will, adding pluggable backends for chat systems, Will's internal brains, pub-sub, and encryption.    A huge number of really smart people gave their thoughts and suggestions throughout the process, not least  @hobson ,  @woohgit ,  @netjunki ,  @sivy ,  @antgel ,  @shadow7412 ,  @brandonsturgeon ,  @pepedocs ,  @tophsic , and  @mike-love .  Read all about what and why here:  What's new in Will 2 ,  And when you're ready to upgrade, here's  the upgrade guide . (Spoiler:  pip install -U will ).  High-level, here's what's new:   Slack support  CLI/Shell backend  Rocket.chat  support, thanks to  antgel .  Will's brains have been abstracted - you can now add custom  analysis ,  generation , and  execution  backends to build everything from a straight regex-bot to a full chatterbot.  Pluggable I/O backends , which is how all of the above were done, and which means adding new platforms is pretty simple.  Pluggable storage  backends.  Pluggable pubsub  backends.  Built-in encryption for storage and pub/sub (with  pluggable backends  as well.)  Lots more intelligence around required settings and verification, to make first starting and debugging Will easier.  Full Python 3 support. (Don't worry, 2.x  isn't going anywhere .)  New  @will gif me  command.  Because it can't all be serious. :)   This release also changes a few bits of behavior, to be consistent:   self.reply()   finally  no longer requires you to tediously pass the  message  back to it.  It's also smart, and backwards compatable with existing plugins.  admin_only  is explicitly flagged for deprecation and removal, to be replaced by the ACL system introduced in 2015 (largely, this is because having two different access control systems is crazy and painful.)  Switching is as easy as adding  ACL = {'admins': ['steven', 'will']}  to your config.py and find/replacing  admin_only=True  with `acl=['admins',] in your codebase.  For now, Will handles backwards compatibility by mapping the old settings into the new places, but he won't forever.  Thanks for updating, and making ongoing maintenence simpler!  If no ACLs are specified and users try to perform restricted commands, they'll be allowed as before, but Will will complain to the console. A new  DISABLE_ACL  setting has been added to turn off the complaining.  You can pass in  channel=  or  room=  when specifying a custom reply location.  If both are passed in, Will uses  channel .   There are a couple  internal  backwards-incompatible changes:   RosterMixin  has been renamed  HipChatRosterMixin  and moved to  will.backends.io_adapters.hipchat .  This change should not affect you unless you were specifically importing RosterMixin in your own plugins - everything in  WillPlugin  has been automatically routed to the right place, in a backwards-compatible way.  Room  and  RoomMixin  have similarly become  HipChatRoom  and  HipChatRoomMixin and moved to will.backends.io_adapters.hipchat`.   As this is a  big  update, please report any bugs you see (no matter how small) to  the github issue tracker .  Thanks in advance for making Will even better!", 
            "title": "2.0.1beta1 - November 7, 2017"
        }, 
        {
            "location": "/releases/#102-october-24-2017", 
            "text": "Fixes and features in this release:   Makes passing the  room=  option  much  easier (you can just use the room's name now,) thanks to  wontonst .  Adds support for jinja  custom_filters  in the  @rendered_template  decorator, thanks to  chillipeper .", 
            "title": "1.0.2 - October 24, 2017"
        }, 
        {
            "location": "/releases/#101-october-10-2017", 
            "text": "Fixes and features in this release:   Fixes what time plugin to not require World Weather's old API, thanks to  woohgit .  Adds Docker support, thanks to  mike-love .  Adds Python 3 support, thanks to  tenzer .", 
            "title": "1.0.1 - October 10, 2017"
        }, 
        {
            "location": "/releases/#100-september-29-2017", 
            "text": "This is the end of major feature development for the hipchat-only version of Will.  Future development will be on 2.x, and while backwards compatability will be aimed for, it's not 100% guaranteed.  Fixes and features in this release:   Makes ACLs be case-insensitive, thanks to  woohgit .  Adds Hipchat card support, also thanks to  woohgit .  Gets Chatoms random topics working again, thanks to  bykof .  Environment overrides for  PLUGINS  and  PLUGIN_BLACKLIST  (semicolon separated) are now possible, thanks to  mark-adams .", 
            "title": "1.0.0 - September 29, 2017"
        }, 
        {
            "location": "/releases/#095-june-23-2017", 
            "text": "Quick bugfix release before the big changeover to 1.0, pluggable backends (Slack support), and more.   Fixed:  @will image me  actually works again thanks to  antgel .", 
            "title": "0.9.5 - June 23, 2017"
        }, 
        {
            "location": "/releases/#094-april-25-2017", 
            "text": "New releases and movement again!  Exciting things in the pipeline for will, and that's starting with a long-awaited release.  Thanks to everyone who both submitted code, and had saint-like patience with it being merged in.   New:  self.append()  and  self.pop()  methods to support list storage, thanks to  woohgit .  Fixed:  @will image me  works again (but requires a google API key - see  config.py , thanks to  shadow7412 .  Fixed:  @will pugs  thankfully works again, thanks to  gordol .  Improvement:  @will help  plugin  now gives plugin-specific help, thanks to  tophsic .  Improvement: Blacklisted modules aren't even attempted to be imported, thanks to  BrianGallew .  Improvement: File storage engine expires properly, thanks to  BrianGallew .  Improvement: Zombie users no longer cause will trouble, thanks to  BrianGallew .  Improvement: Will now no longer gets stuck if organizations have more than 2000(!) hipchat rooms, courtesy of  woparry  and  danbourke .  Improvement: V2 API calls for multiple rooms now properly uses  max-results  and doesn't hang, thanks to  chillipeper .  Improvement: Much-improved test runners, and proper case for Bitbucket, thanks to  mark-adams .  Improvement:  _available_rooms  is now populated with  Room  objects, regardless of whether you use V1 or V2, thanks to  jcdyer .  Improvement: Output logging now includes timestamps by default, thanks to  pepedocs .  Improvement: Upgraded to  hiredis    0.2 to get windows builds working, thanks to  Regner .  Improvement: Updated to the new pagerduty docs, thanks to  woohgit .  Improvement: Generation script doesn't make a duplicate  hi  response, thanks to  brandonsturgeon  and  derek-adair .", 
            "title": "0.9.4 - April 25, 2017"
        }, 
        {
            "location": "/releases/#093-september-11-2015", 
            "text": "Thanks for your patience on this long-delayed release!  Here's what's new:   New: Will watches bitbucket, and alerts on downtime, thanks to  mvanbaak .  New:  @will urban dictionary ______ , thanks to  Ironykins .  New: 1-1 messages now support HTML, thanks to  AndrewBurdyug  and  brandonsturgeon  Improvement: Batch-getting of rooms, thanks to  charlax .  Improvement: Better handling of uptime check edge cases, thanks to  woohgit .  Improvement: Proper docs for installing redis on ubuntu/debian, thanks to  kenden .  Improvement: Pulled an extraneous doc page, thanks to  woohgit .  Improvement: Fixes to the route doc syntax, thanks to  brandonsturgeon .  Improvement: Docs now fit the new mkdocs format, thanks to  d0ugal .  Improvement: New travis.yml setup for easier travis running, and plugged my CircleCI builds into the github repo. All future PRs should automatically have tests run!", 
            "title": "0.9.3 - September 11, 2015"
        }, 
        {
            "location": "/releases/#092-june-5-2015", 
            "text": "Fixes bug that caused will not to join all rooms if  ROOMS  was missing. Thanks to  camilonova  for the report!", 
            "title": "0.9.2 - June 5, 2015"
        }, 
        {
            "location": "/releases/#091-may-30-2015", 
            "text": "Fixes bug that affected  @will s - thanks to  woohgit  for the report!", 
            "title": "0.9.1 - May 30, 2015"
        }, 
        {
            "location": "/releases/#09-may-29-2015", 
            "text": "BREAKING:  Module change. New  will.plugins.fun  module. Existing will installs will need to add it to your  config.py  to keep the fun!  New:  Support for Pagerduty workflows, thanks to  woohgit . This is really tremendous stuff.  Check out the docs here !  New:  Pluggable storage backends , with support for couchbase and local file storage, in addition to redis.  Many thanks to  borgstrom  New:  ACL  functionality, thanks to  woohgit .  Backwards-compatable, even!  New: Made will a little more fun, thanks to  camilonova .  Hint: it involves the world's most meme-friendly dog.  New: Will can now construct google poems, thanks to  AirbornePorcine . Truly, his creativity knows no bounds.  Improvement: Moved stuff like that into a new \"fun\" module.  Dry, anti-fun people can now disable it more easily. ;)  Improvement: \"What time is it\" now outputs time zones, thanks to  woohgit .  Improvement: No more rate-limit problems on the v2 token, thanks to  grundprinzip .  Improvement: Messages are now  .strip() ed before being compared, to handle  frozen-fingered-typos .  Thanks,  woohgit !  Fix: Typo in the docs gone.  Thanks,  woohgit .  Fix: Bugs in proxy support are fixed, thanks to  dmuntean .", 
            "title": "0.9 - May 29, 2015"
        }, 
        {
            "location": "/releases/#082-april-24-2015", 
            "text": "Fixes an odd remaining bug with  @randomly , thanks to  camilonova 's continued debugging.", 
            "title": "0.8.2 - April 24, 2015"
        }, 
        {
            "location": "/releases/#081-april-23-2015", 
            "text": "Moves  version  plugin into admin, so it just works for most users.", 
            "title": "0.8.1 - April 23, 2015"
        }, 
        {
            "location": "/releases/#08-april-23-2015", 
            "text": "What happens when life gets busy and we go a full month and a half between will releases?  Lots and lots:  New: All-new  @will who is in this room?  command, thanks to  puug .  New: Will now can shorten links via bitly  @will bitly http://example.com , thanks to  keNzi .  New: Will now supports a  PROXY_URL  setting, for getting around funky firewalls, thanks to  dmuntean .  New:  @will version  command to check version number, thanks to  woohgit .  New: Awesome new  remind ___ to ___ at ___ , thanks to  woohgit .  New: Will now keeps an eye on hipchat's uptime as well, thanks to  netjunki .  Fix: a breaking bug in the  @randomly  decorator, thanks to a report by  camilonova .  Support: Handles a breaking change in the hipchat API, thanks to  brandonsturgeon .  Support: Updates to v2 of the underquoted API, thanks  jessamynsmith .  Support: Updated to the new WorldWeatherOnline endpoint, since they had DDOS problems, thanks to  woohgit .  Improvement: The most important kind of PRs.  Spelling fixes.  Many thanks to  jquast .  Improvement:  self.save()  now accepts an  expire  value, thanks to  netjunki .  Improvement: PEP8 passes for the whole codebase, with flake8 added to automated tests.", 
            "title": "0.8 - April 23, 2015"
        }, 
        {
            "location": "/releases/#073-march-3-2015", 
            "text": "Fixed a breaking bug to world time, thanks to  woohgit .", 
            "title": "0.7.3 - March 3, 2015"
        }, 
        {
            "location": "/releases/#072-february-27-2015", 
            "text": "Improved handling when  .reply()  is called incorrectly, thanks to a report by  dothak  Fixed the  annoying  \"github's ok\" on first launch.  Restored Python 2.6 compatability thanks to the report and patience of  JPerkster .  Lots of code cleanup toward pep8.", 
            "title": "0.7.2 - February 27, 2015"
        }, 
        {
            "location": "/releases/#071-february-5-2015", 
            "text": "Improved talkbackbot regex, suggested by  PrideRage .", 
            "title": "0.7.1 - February 5, 2015"
        }, 
        {
            "location": "/releases/#070-february-4-2015", 
            "text": "Adds a port of the awesome  talkbackbot , thanks to  jessamynsmith , who super-kindly ported it at my request!  Oh, yeah. That port also includes the first proper tests in will, and a pretty solid pattern for testing plugins.  Woo!  More huge thanks to  jessamynsmith .", 
            "title": "0.7.0 - February 4, 2015"
        }, 
        {
            "location": "/releases/#069-january-30-2015", 
            "text": "Fixed copypasta error caught by the keen eye of  dpoirier .", 
            "title": "0.6.9 - January 30, 2015"
        }, 
        {
            "location": "/releases/#068-january-30-2015", 
            "text": "Will now supports templates directories within plugins.  Just put a  templates  directory in the plugin's module, and it will be detected.  Thanks to  sivy  for the idea and willingness to get it done!", 
            "title": "0.6.8 - January 30, 2015"
        }, 
        {
            "location": "/releases/#067-january-29-2015", 
            "text": "Addition of  .get_user_by_nick()  method, to look up users by nick, thanks to  sivy .  Bugfix to  ALLOW_INSECURE_HIPCHAT_SERVER  when specified in  config.py , thanks to  sivy .", 
            "title": "0.6.7 - January 29, 2015"
        }, 
        {
            "location": "/releases/#066-january-29-2015", 
            "text": "New  room.history  attribute with a room's history, thanks to  PrideRage  New setting:  ALLOW_INSECURE_HIPCHAT_SERVER , which will disable SSL checks (you're on your own), thanks to  sivy .  Adds support for V2 of the WorldWeatherOnline API (used for world times, weather) thanks to  woohgit .  Adds new release and doc deploy scripts, so the github  releases  are kept up to date.  Thanks to  crccheck  for noticing and reporting they were stale!", 
            "title": "0.6.6 - January 29, 2015"
        }, 
        {
            "location": "/releases/#065-january-23-2015", 
            "text": "Removes mkdocs from the production requirements.txt to fix a Jinja version problem.  Thanks to the report from  PrideRage .", 
            "title": "0.6.5 - January 23, 2015"
        }, 
        {
            "location": "/releases/#064-january-19-2015", 
            "text": "Switches to bottle to cherrypy over gevent, which should solve lingering gevent DNS threading issues, thanks to  wohali .  Support for @will, @WILL, @wIll, thanks to  neronmoon", 
            "title": "0.6.4 - January 19, 2015"
        }, 
        {
            "location": "/releases/#063-december-30-2014", 
            "text": "Better error handling for weirdly formatted messages.  Better generated README, thanks to  bsvetchine .", 
            "title": "0.6.3 - December 30, 2014"
        }, 
        {
            "location": "/releases/#062-september-23-2014", 
            "text": "Bugfix on  generate_will_project , thanks to the report by  MattyDub .", 
            "title": "0.6.2 - September 23, 2014"
        }, 
        {
            "location": "/releases/#061-september-23-2014", 
            "text": "Freezes apscheduler to   3.0, since its API was backwards incompatibile.", 
            "title": "0.6.1 - September 23, 2014"
        }, 
        {
            "location": "/releases/#060-september-17-2014", 
            "text": "Methods in a single class now share a common instance, thanks to  amckinley .  Redis connections are now pooled (which should help with \"max clients exceeded\" errors), thanks to  carsongee .  Preliminary travis ci support, thanks to  pcurry .  More gramatically correct documentation by  hobson .", 
            "title": "0.6.0 - September 17, 2014"
        }, 
        {
            "location": "/releases/#057-september-3-2014", 
            "text": "Improvements to setup.py to be robust a variety of linux/unixes by  hobson .", 
            "title": "0.5.7 - September 3, 2014"
        }, 
        {
            "location": "/releases/#056-august-26-2014", 
            "text": "Fix for 1-1 bootstrapping bug, thanks to  adamcin .", 
            "title": "0.5.6 - August 26, 2014"
        }, 
        {
            "location": "/releases/#055-august-25-2014", 
            "text": "Full html support in 1-1 chats, thanks to  adamcin .", 
            "title": "0.5.5 - August 25, 2014"
        }, 
        {
            "location": "/releases/#054-july-22-2014", 
            "text": "Upgrades bottle to 0.12.6 to fix  security bug .", 
            "title": "0.5.4 - July 22, 2014"
        }, 
        {
            "location": "/releases/#053-july-11-2014", 
            "text": "@randomly  functions now can run on the 59th minute, thanks to  tomokas .  Bad merge that duplicated  help.py  fixed by  netjunki .  \"global name 'params' is not defined\" bug fixed by  amckinley .", 
            "title": "0.5.3 - July 11, 2014"
        }, 
        {
            "location": "/releases/#051-july-2-2014", 
            "text": "New  HIPCHAT_SERVER  setting to support  beta HipChat Server , thanks to  mrgrue .", 
            "title": "0.5.1 - July 2, 2014"
        }, 
        {
            "location": "/releases/#05-omnibus-june-27-2014", 
            "text": "Big, big release, with backwards-incompatble changes.  Please read all the notes on this one!  All-new config and environment setup, including an all-new  config.py  for plugin configuration, and all non-sensitive settings.  Much, much improved bootstrapping code that validates settings, gives helpful output, and generally helps you get will running.  Documentation!  Real-live documentation!  Breaking :  WILL_TOKEN  has been renamed  WILL_HIPCHAT_V1_TOKEN .  New  @require_settings  decorator for plugins to request validation that needed settings are present.  Will now has a concept of modules (groups of plugins), and groups help output according.", 
            "title": "0.5 Omnibus - June 27, 2014"
        }, 
        {
            "location": "/releases/#0410-june-6-2014", 
            "text": "Brand-new  admin_only  argument to  hear()  and  respond_to() , thanks to  rbp .  If a user is not in  WILL_ADMINS , they won't be able to run any  admin_only=True  plugins.  Default for  WILL_ADMINS  is all users to retain backwards-compatibility.  All commands in the  storage.py  plugin are now admin-only.  help  now only responds to direct asks, allowing other plugins to handle \"help me with x\", thanks to  bfhenderson", 
            "title": "0.4.10 - June 6, 2014"
        }, 
        {
            "location": "/releases/#049-may-28-2014", 
            "text": "Passing a  room  to a  .say()  now works properly, thanks to  rbp .  New optional  WILL_LOGLEVEL  setting, thanks to  dpoirier .", 
            "title": "0.4.9 - May 28, 2014"
        }, 
        {
            "location": "/releases/#048-may-21-2014", 
            "text": "Will now ignores all previously sent messages properly, by passing in  bot  as the resource instead of an ugly time hack, thanks to  dpoirier .", 
            "title": "0.4.8 - May 21, 2014"
        }, 
        {
            "location": "/releases/#047-may-15-2014", 
            "text": "Will now prints a helpful message if one of your  WILL_ROOMS  is wrong, and continues starting, instead of crashing in a fiery ball, thanks to  crccheck .", 
            "title": "0.4.7 - May 15, 2014"
        }, 
        {
            "location": "/releases/#046-may-5-2014", 
            "text": "@route  decorators now honor all bottle arguments, most helpfully  method !", 
            "title": "0.4.6 - May 5, 2014"
        }, 
        {
            "location": "/releases/#045-may-2-2014", 
            "text": "Awesome new help system by  quixeybrian .  \"@will help\" now only displays functions with docstrings, and formats them nicely.  Old help (regexes and all) is available at \"@will programmer help\"", 
            "title": "0.4.5 - May 2, 2014"
        }, 
        {
            "location": "/releases/#044-april-22-2014", 
            "text": "Removes the dependence on the v1 token (though it still helps with rate-limiting), thanks to  bfhenderson .  Much friendlier error message on an invalid API key, thanks to  adamgilman .", 
            "title": "0.4.4 - April 22, 2014"
        }, 
        {
            "location": "/releases/#043-april-1-2014", 
            "text": "Support for hundreds of users and rooms without hitting the API limit.  get_all_users  use of the bulk API  added  by  quixeybrian .  Thanks also to  jbeluch  and  jdrukman  for nudges in the right direction.  The start of some useful comments - the meat of will was hacked out by one person over a handful of days and it looks that way. Slowly but surely making this codebase more friendly to other contributions!  Added a CONTRIBUTING.md file thanks to  michaeljoseph .  Proper releases in the docs, and an updated  AUTHORS  file.  If you see something awry, send a PR!", 
            "title": "0.4.3 - ~ April 1, 2014"
        }, 
        {
            "location": "/releases/#04-march-2014", 
            "text": "Ye olden past before we started keeping this list.  All contributions by GreenKahuna.  Will did everything that's not in the release list above.  That's called lazy retconning release lists!    Make sure nothing from the readme is missed.", 
            "title": "0.4 - ~ March 2014"
        }, 
        {
            "location": "/roadmap/", 
            "text": "Last Update: November 7, 2017\n\n\nQuick note\n:  I'll be updating this with more information now that Will 2.0 is out, and we're learning what really makes sense in the wild.  What's below is roughly the roadmap from April 2017.\n\n\nA Note from Steven\n\n\n\n\n\"Open source projects with no funding mechanism typically stagnate and die.\" \n-\nGreenSock\n\n\n\n\nI read that quote a few years ago when considering using GreenSock in a front-end product, and it stuck with me since, in both Will and my other projects.  At first, the statement really bugged me - but as I looked objectively at my own long list of abandoned open-source work, I realized there was a deep truth to it.\n\n\nWill has gone on a similar journey - it was written with the support from a couple of my day jobs, and after those left, my time dried up, and the project started to stagnate.\n\n\nThat stagnation has bugged me for a long time, but I didn't really have a way to solve the problem until now.\n\n\nWhat this document outlines is a future roadmap for Will that's both open-source and revenue-generating.  A project that can keep the codebase active, healthy, and adding new features (First up: Slack), while also paying my (and hopefully other folks') bills - and with some luck, maybe even changing the world.\n\n\nI recognize that a lot of people have contributed to will, and while many of you will be thrilled by the prospect of active, sustainable development, a few folks might have the \"OMG WHAT KIND OF SELL OUT BULL*** IS THIS??!?!\".   To those folks, I'd like to reiterate - Will is open-source, and is going to stay that way. :) \n\n\nNow let's talk about how.\n\n\nNote\n: I use the royal \"we\" below because it feels more natural in the long-term.  Right now it's just me and it's awkward.  Thanks for rolling with it.\n\n\nOverall Project Structure and Goals\n\n\nWill is being founded as a company, and with the core chat bot product, we'll have both the open-source library and a PaaS/SaaS service (ala Wordpress.com/.org).  The core of the company is around an idea we call Personal AI.\n\n\n(Read more about the mission at \nhttp://heywill.io/mission\n.)\n\n\nThis shift means growing the project to something much bigger than a hipchat bot, and into a write-once, run anywhere platform for chat bots, AIs, and fun new holy-crap-that's-amazing ideas.\n\n\nThe big goal is to provide an easy-to-build-on batteries-included platform that bridges modes of communication (HipChat, Slack, SMS, Email, Telegram, FB Messenger, etc) with services (IFTTT, Amazon AI, IBM Watson, Google APIs, etc) and built-in AI tools (NLP, ML, DL, etc).  \n\n\nThis broader platform serves as an OS for AI development, and has the tremendously creative working name of AIOS.\n\n\nDevelopers can build AIOS apps (our current plugins) for will using any and all of those tools, and run them on their personal wills or distribute them to a broader audience.\n\n\nWill the company will focus, like Wordpress, on running the PaaS and SaaS platforms, and a marketplace for apps.  Our goal is to keep Will development brisk, bring in talented folks across the spectrum, and keep Will available to anyone, anywhere on the planet, regardless of financial or technical access. \n\n\nProject Roadmap\n\n\nHere's the nuts and bolts of how, today, we see this rolling out.\n\n\n0.9.4 - Released April 25, 2017 - catches up almost all open PRs\n\n\n1.0 - Released September 29, 2017 closes up existing issues, code cleanup and prep for improvements\n\n\n2.0 - November 4, 2017 - Slack Support, \nIOBackend\n documented and working.  PRs for new IOs accepted.\n\n\n2.1 - A pure-python pubsub backend, Telegram Support, and a cleaned up API for introspecting and accessing the results of analysis and generation.\n\n\n2.2 - API Backend released, via an \nAPIBackend\n implementation of \nIOBackend\n.  Allows folks to spin up Will and control him completely via a RESTful API.\n\n\n2.3 - IFTTT Support, \nSkillsBackend\n documented and working.  PRs for new Skills accepted.\n\n\n2.5 - Will UI, with on-the-fly config, plugin enable/disable, and restartability.\n\n\n2.6 - App specs for AIOS and \nAIOSApp\n class released.\n\n\n2.7 - Release of first five apps. TBD, but considered: (Image me, Remind me, Groceries, News Summary, Scattegories, Stale Package Finder)\n\n\n3.0 - App Marketplace released, Git library integration released, and all existing Will plugins released as AIOS apps.\n\n\n2.0+ - \"The root of all evil is premature optimization.\"  Releases after 2.0 are likely to move in a direction of improved AIOS features, more built-in AI tools, smarter and richer message processing and context, cross-app communication, and speed/reliability bumps.  We'd also like to look at the feasibility of authoring apps in both Python and JS.  \n\n\nThat said, this will really be determined after 2.0 is released, the launch craziness settles down, and we hear from the community and customers which directions need the most support, and what pain points folks are feeling the most.\n\n\nWe can't wait to have those discussions.\n\n\nRelease Schedule.\n\n\nA new version of Will will be released on the 1st of every month, with a 12-month guarantee for \nIOBackend\n, \nSkillsBackend\n, API and AIOS APK function stability, and a minimum 6 month deprecation warning.\n\n\nQuestions and Comments\n\n\nI've set up an issue \nhere\n to talk through this new direction, hear people's thoughts, comments, suggestions, and feedback.\n\n\nI'm so excited to take will in this new, bigger direction, find consistent time and energy to keep him maintained, and grow him into something amazing together.\n\n\nThank you so much for contributing to will thus far, and I can't wait to see where we take him together!\n\n\n-Steven", 
            "title": "Roadmap"
        }, 
        {
            "location": "/roadmap/#a-note-from-steven", 
            "text": "\"Open source projects with no funding mechanism typically stagnate and die.\" \n- GreenSock   I read that quote a few years ago when considering using GreenSock in a front-end product, and it stuck with me since, in both Will and my other projects.  At first, the statement really bugged me - but as I looked objectively at my own long list of abandoned open-source work, I realized there was a deep truth to it.  Will has gone on a similar journey - it was written with the support from a couple of my day jobs, and after those left, my time dried up, and the project started to stagnate.  That stagnation has bugged me for a long time, but I didn't really have a way to solve the problem until now.  What this document outlines is a future roadmap for Will that's both open-source and revenue-generating.  A project that can keep the codebase active, healthy, and adding new features (First up: Slack), while also paying my (and hopefully other folks') bills - and with some luck, maybe even changing the world.  I recognize that a lot of people have contributed to will, and while many of you will be thrilled by the prospect of active, sustainable development, a few folks might have the \"OMG WHAT KIND OF SELL OUT BULL*** IS THIS??!?!\".   To those folks, I'd like to reiterate - Will is open-source, and is going to stay that way. :)   Now let's talk about how.  Note : I use the royal \"we\" below because it feels more natural in the long-term.  Right now it's just me and it's awkward.  Thanks for rolling with it.", 
            "title": "A Note from Steven"
        }, 
        {
            "location": "/roadmap/#overall-project-structure-and-goals", 
            "text": "Will is being founded as a company, and with the core chat bot product, we'll have both the open-source library and a PaaS/SaaS service (ala Wordpress.com/.org).  The core of the company is around an idea we call Personal AI.  (Read more about the mission at  http://heywill.io/mission .)  This shift means growing the project to something much bigger than a hipchat bot, and into a write-once, run anywhere platform for chat bots, AIs, and fun new holy-crap-that's-amazing ideas.  The big goal is to provide an easy-to-build-on batteries-included platform that bridges modes of communication (HipChat, Slack, SMS, Email, Telegram, FB Messenger, etc) with services (IFTTT, Amazon AI, IBM Watson, Google APIs, etc) and built-in AI tools (NLP, ML, DL, etc).    This broader platform serves as an OS for AI development, and has the tremendously creative working name of AIOS.  Developers can build AIOS apps (our current plugins) for will using any and all of those tools, and run them on their personal wills or distribute them to a broader audience.  Will the company will focus, like Wordpress, on running the PaaS and SaaS platforms, and a marketplace for apps.  Our goal is to keep Will development brisk, bring in talented folks across the spectrum, and keep Will available to anyone, anywhere on the planet, regardless of financial or technical access.", 
            "title": "Overall Project Structure and Goals"
        }, 
        {
            "location": "/roadmap/#project-roadmap", 
            "text": "Here's the nuts and bolts of how, today, we see this rolling out.  0.9.4 - Released April 25, 2017 - catches up almost all open PRs  1.0 - Released September 29, 2017 closes up existing issues, code cleanup and prep for improvements  2.0 - November 4, 2017 - Slack Support,  IOBackend  documented and working.  PRs for new IOs accepted.  2.1 - A pure-python pubsub backend, Telegram Support, and a cleaned up API for introspecting and accessing the results of analysis and generation.  2.2 - API Backend released, via an  APIBackend  implementation of  IOBackend .  Allows folks to spin up Will and control him completely via a RESTful API.  2.3 - IFTTT Support,  SkillsBackend  documented and working.  PRs for new Skills accepted.  2.5 - Will UI, with on-the-fly config, plugin enable/disable, and restartability.  2.6 - App specs for AIOS and  AIOSApp  class released.  2.7 - Release of first five apps. TBD, but considered: (Image me, Remind me, Groceries, News Summary, Scattegories, Stale Package Finder)  3.0 - App Marketplace released, Git library integration released, and all existing Will plugins released as AIOS apps.  2.0+ - \"The root of all evil is premature optimization.\"  Releases after 2.0 are likely to move in a direction of improved AIOS features, more built-in AI tools, smarter and richer message processing and context, cross-app communication, and speed/reliability bumps.  We'd also like to look at the feasibility of authoring apps in both Python and JS.    That said, this will really be determined after 2.0 is released, the launch craziness settles down, and we hear from the community and customers which directions need the most support, and what pain points folks are feeling the most.  We can't wait to have those discussions.", 
            "title": "Project Roadmap"
        }, 
        {
            "location": "/roadmap/#release-schedule", 
            "text": "A new version of Will will be released on the 1st of every month, with a 12-month guarantee for  IOBackend ,  SkillsBackend , API and AIOS APK function stability, and a minimum 6 month deprecation warning.", 
            "title": "Release Schedule."
        }, 
        {
            "location": "/roadmap/#questions-and-comments", 
            "text": "I've set up an issue  here  to talk through this new direction, hear people's thoughts, comments, suggestions, and feedback.  I'm so excited to take will in this new, bigger direction, find consistent time and energy to keep him maintained, and grow him into something amazing together.  Thank you so much for contributing to will thus far, and I can't wait to see where we take him together!  -Steven", 
            "title": "Questions and Comments"
        }
    ]
}